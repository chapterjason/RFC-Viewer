<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AST Text Renderer & Inspector</title>
  <style>
    :root {
      --bg: #0b0c0f;
      --panel: #12141a;
      --muted: #a6adbb;
      --text: #e7e9ee;
      --accent: #7aa2f7;
      --danger: #ff6b6b;
      --ok: #22c55e;
      --warn: #f59e0b;
      --border: #1f2430;

      /* Type colors (muted, distinct, cohesive) */
      --Paragraph: rgba(88, 130, 193, 0.22);         /* muted blue */
      --BlankLine: rgba(255, 255, 255, 0.03);        /* near background */
      --IndentedBlock: rgba(149, 110, 186, 0.22);    /* muted purple */
      --Metadata: rgba(210, 160, 96, 0.22);          /* muted orange */
      --Title: rgba(84, 170, 120, 0.22);             /* muted green */
      --SectionTitle: rgba(190, 110, 110, 0.22);     /* muted red */
      /* PageBreak: near-background, distinct from BlankLine */
      --PageBreak: rgba(114, 124, 202, 0.08);
      --PageFooter: rgba(114, 124, 202, 0.08);
      --PageHeader: rgba(114, 124, 202, 0.08);
      --List: rgba(88, 176, 168, 0.22);              /* muted teal */
      --DefinitionList: rgba(142, 180, 102, 0.22);   /* olive */
      --TableOfContents: rgba(176, 146, 100, 0.22);  /* muted amber */
      --Figure: rgba(206, 120, 160, 0.22);           /* muted rose */
      --HttpResponse: rgba(122, 162, 247, 0.18);     /* soft blue tint */
      --Document: rgba(255, 255, 255, 0.06);         /* very subtle */

      /* Sizing */
      --code-size: 14px;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: Consolas, monospace;
      color: var(--text);
      background: var(--bg);
    }
    /* drag guide for splitter (no layout during drag) */
    .splitter-guide { position: absolute; top: 0; bottom: 0; width: 6px; background: #1d2a45; border-left: 1px solid var(--border); border-right: 1px solid var(--border); pointer-events: none; z-index: 10; }
    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100%;
    }
    header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }
    header h1 { font-size: 14px; margin: 0; font-weight: 600; letter-spacing: 0.3px; }
    header .actions { margin-left: auto; display: flex; gap: 8px; }
    button, .btn {
      background: #1b2331;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }
    /* Ensure all UI controls render in monospace */
    button, .btn, input, select, textarea, label { font-family: inherit; font-variant-ligatures: none; }
    button:hover { border-color: #2b3445; }
    .layout {
      display: grid;
      position: relative;
      grid-template-columns: var(--left-width, 60%) 6px 1fr; /* left | splitter | right */
      gap: 0;
      height: 100%;
    }
    .splitter {
      background: #101521;
      border-left: 1px solid var(--border);
      border-right: 1px solid var(--border);
      cursor: col-resize;
    }
    .splitter:hover { background: #162033; }
    body.dragging .splitter { background: #1d2a45; }
    body.dragging { user-select: none; cursor: col-resize; }
    .panel { display: flex; flex-direction: column; border-right: 1px solid var(--border); }
    .panel:last-child { border-right: none; }
    .panel header { border: none; border-bottom: 1px solid var(--border); }
    .panel .body { flex: 1; min-height: 0; }

    .input-wrap { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .input-controls { display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-bottom: 1px solid var(--border); }
    textarea {
      width: 100%; height: 100%; box-sizing: border-box; resize: none; outline: none;
      border: 1px solid var(--border); background: #0c111b; color: var(--text);
      padding: 12px; font-size: var(--code-size); line-height: 1.6;
      border-radius: 8px;
      tab-size: 4;
    }
    textarea:focus {
      border-color: #2b3445;
      box-shadow: inset 0 0 0 1px #2b3445, 0 0 0 2px rgba(122,162,247,0.15);
    }

    .render-wrap { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .legend { display: flex; flex-wrap: wrap; gap: 6px 10px; padding: 8px 12px; border-bottom: 1px solid var(--border); background: #0f1320; }
    .legend .item { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; color: var(--muted); cursor: pointer; user-select: none; font-family: inherit; }
    .legend .swatch { width: 12px; height: 12px; border-radius: 3px; outline: 1px solid var(--border); }
    .legend .item input { margin: 0; }

    .layout, .panel { min-height: 0; }
    .render-area { position: relative; height: 100%; overflow: auto; }
    .output {
      position: relative; margin: 0; padding: 8px 12px; background: transparent;
      border: none; color: var(--text); white-space: pre; line-height: 1.6; font-size: var(--code-size);
      font-family: Consolas, monospace;
      font-variant-ligatures: none;
    }
    .output .line { display: block; padding: 0 6px; }
    .output .line::selection { background: rgba(122, 162, 247, 0.35); }
    /* Muted styling for visible whitespace markers */
    .output .line .ws { color: var(--muted); opacity: 0.7; }
    .output .line .ws.ws-tab { letter-spacing: 0; }
    /* Ensure blank lines occupy vertical space without inserting spaces */
    .output .line:empty::before { content: "\200B"; }
    /* Visualize page breaks explicitly */
    .output .line.page-break { color: var(--muted); }

    /* Node block container to group multi-line nodes for unified outlines */
    .output .block {
      display: block;
      position: relative;
      /* Always show a subtle border around rendered items */
      border: 1px solid var(--border);
      border-radius: 0;
      margin: 2px 0;
    }
    /* Make labels non-selectable so they don't end up in clipboard */
    .output .block .type-badge { user-select: none; -webkit-user-select: none; -moz-user-select: none; pointer-events: none; }
    .output .block .summary { display: none; color: var(--muted); padding-left: 8px; }
    /* When collapsed, hide the entire block to focus only on checked types */
    .output .block.collapsed { display: none; }
    .output .block.hover { outline: 1px solid #2d3b59; outline-offset: -1px; }
    .output .block.selected { outline: 2px solid var(--accent); outline-offset: -1px; }

    /* Small type label at top-right of each block */
    .output .block .type-badge {
      position: absolute;
      top: 0;
      right: 0;
      font-size: 10px;
      line-height: 1;
      color: var(--text);
      background: var(--border);
      border: 1px solid var(--border);
      border-radius: 0;
      padding: 2px 4px;
      pointer-events: none; /* do not block clicks on the block */
      opacity: 0.9;
    }

    /* Badges share the same background as borders (override any per-type tints) */
    .output .block[data-type] .type-badge { background: var(--border); }

    /* Highlight overlays via background on lines for the node’s type (gated by visibility classes) */
    .type-visible-Paragraph .output .line[data-type="Paragraph"] { background: var(--Paragraph); }
    .type-visible-BlankLine .output .line[data-type="BlankLine"] { background: var(--BlankLine); }
    .type-visible-IndentedBlock .output .line[data-type="IndentedBlock"] { background: var(--IndentedBlock); }
    .type-visible-Metadata .output .line[data-type="Metadata"] { background: var(--Metadata); }
    .type-visible-Title .output .line[data-type="Title"] { background: var(--Title); }
    .type-visible-SectionTitle .output .line[data-type="SectionTitle"] { background: var(--SectionTitle); }
    .type-visible-PageBreak .output .line[data-type="PageBreak"] { background: var(--PageBreak); }
    .type-visible-PageFooter .output .line[data-type="PageFooter"] { background: var(--PageFooter); }
    .type-visible-PageHeader .output .line[data-type="PageHeader"] { background: var(--PageHeader); }
    .type-visible-List .output .line[data-type="List"] { background: var(--List); }
    .type-visible-DefinitionList .output .line[data-type="DefinitionList"] { background: var(--DefinitionList); }
    .type-visible-TableOfContents .output .line[data-type="TableOfContents"] { background: var(--TableOfContents); }
    .type-visible-Figure .output .line[data-type="Figure"] { background: var(--Figure); }
    .type-visible-HttpResponse .output .line[data-type="HttpResponse"] { background: var(--HttpResponse); }
    .type-visible-Document .output .line[data-type="Document"] { background: var(--Document); }

    /* Hover and selection are now applied to .block containers */

    .details { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .details .header { display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-bottom: 1px solid var(--border); background: #0f1320; }
    .details .header .title { font-size: 12px; font-weight: 600; margin: 0; letter-spacing: 0.2px; }
    .details .content { height: 100%; overflow: auto; }
    .details pre { margin: 0; padding: 12px; white-space: pre; font-size: 12px; line-height: 1.45; }

    .status { font-size: 12px; color: var(--muted); padding: 8px 12px; border-top: 1px solid var(--border); }
    .error { color: var(--danger); }
  </style>
</head>
<body>
  <div class="app" style="grid-template-rows: auto auto 1fr auto; height: 100vh;">
    <header style="gap: 16px; align-items: flex-start;">
      <h1>AST Text Renderer & Inspector</h1>
      <div class="actions" style="align-items: center; gap: 10px; margin-left: auto;">
        <button id="btnRender">Render</button>
        <button id="btnSample" title="Insert a small sample AST">Sample</button>
        <button id="btnClear">Clear</button>
      </div>
      <div style="display:flex; flex-direction: column; gap: 4px; width: min(900px, 55vw); min-width: 300px;">
        <div style="display:flex; align-items:center; gap:6px;">
          <span class="muted">AST JSON</span>
          <small class="muted">Document node expected</small>
        </div>
        <div class="input-controls" style="gap: 6px;">
          <button id="btnOpenFile" title="Select a local file (.txt or .json)">Open File</button>
          <input id="fileInput" type="file" accept=".txt,.json,text/plain,application/json" style="display:none" />
          <input id="urlInput" type="url" placeholder="https://www.rfc-editor.org/rfc/rfc6749.txt" value="https://www.rfc-editor.org/rfc/rfc6749.txt" style="flex: 1 1 420px; min-width: 180px; max-width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid var(--border); background: #0c111b; color: var(--text);" />
          <button id="btnFetchUrl" title="Fetch URL and parse as RFC text">Fetch URL</button>
        </div>
        <textarea id="input" rows="2" placeholder='{"type":"Document","children":[...]}'></textarea>
      </div>
    </header>

    <div class="legend" id="legend" style="border-top: 1px solid var(--border);"></div>

    <div class="layout" id="mainLayout" style="height: 100%; min-height: 0;">
      <div class="panel render-panel" style="border-right: 1px solid var(--border); min-height: 0;">
        <div class="render-area" id="renderArea" style="height: 100%; min-height: 0;">
          <pre class="output" id="output"></pre>
        </div>
      </div>
      <div class="splitter" id="splitter" aria-label="Resize panels" role="separator" aria-orientation="vertical" tabindex="0"></div>
      <div class="panel" style="min-height: 0;">
        <div class="details">
          <div class="header">
            <span class="title">Selected Node</span>
            <span id="selInfo" class="muted"></span>
            <div style="margin-left: auto; display:flex; gap: 8px;">
              <button id="btnClearSelection">Clear Selection</button>
            </div>
          </div>
          <div class="content"><pre id="nodeJson">(none)</pre></div>
        </div>
      </div>
    </div>

    <div class="status" id="status"></div>
  </div>

  <script type="module">
    import { renderNode } from './dist/Tree/Render/RenderNode.js';
    import { parse } from './dist/Tree/Parser.js';
    import { ArrayCursor } from './dist/Utils/ArrayCursor.js';

    // UI logic
    const inputEl = document.getElementById('input');
    const outputEl = document.getElementById('output');
    const statusEl = document.getElementById('status');
    const legendEl = document.getElementById('legend');
    const nodeJsonEl = document.getElementById('nodeJson');
    const selInfoEl = document.getElementById('selInfo');

    const btnRender = document.getElementById('btnRender');
    const btnSample = document.getElementById('btnSample');
    const btnClear = document.getElementById('btnClear');
    const btnClearSelection = document.getElementById('btnClearSelection');
    const urlInput = document.getElementById('urlInput');
    const btnFetchUrl = document.getElementById('btnFetchUrl');
    const btnOpenFile = document.getElementById('btnOpenFile');
    const fileInput = document.getElementById('fileInput');
    const layoutEl = document.getElementById('mainLayout');
    const splitterEl = document.getElementById('splitter');

    let currentAst = null;
    let nodeMap = new Map(); // nodeId -> node
    let nodeLines = new Map(); // nodeId -> array of line elements
    let nodeContainers = new Map(); // nodeId -> block container element
    let visibleTypes = new Set(); // which types are toggled visible
    let selectedNodeId = null;
    let collapseAll = false;
    let showWhitespace = true; // whether to visualize spaces and tabs
    let isDragging = false;
    let containerRect = null;
    let minLeftPx = 740; // will be recomputed based on 72ch
    let minRightPx = 240; // slightly smaller JSON panel for compactness
    let currentLeft = null;

    const KNOWN_TYPES = [
      'Document','Title','SectionTitle','Metadata','Paragraph','IndentedBlock','List','DefinitionList','TableOfContents','Figure','HttpResponse','BlankLine','PageHeader','PageFooter','PageBreak'
    ];
    const MAX_INPUT_PREVIEW_BYTES = 1_000_000;

    function setStatus(text, isError=false) {
      statusEl.textContent = text || '';
      statusEl.classList.toggle('error', !!isError);
    }

    function escapeHtml(s) {
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function clearRender() {
      outputEl.innerHTML = '';
      legendEl.innerHTML = '';
      nodeMap.clear();
      nodeLines.clear();
      nodeContainers.clear();
      selectedNodeId = null;
      nodeJsonEl.textContent = '(none)';
      selInfoEl.textContent = '';
    }

    function makeNodeId(node, index) {
      // Prefer stable key: type@startLine:startColumn-endLine:endColumn#index
      const p = node.position || { start: {line: 0, column: 0}, end: {line: 0, column: 0} };
      return `${node.type}@${p.start?.line ?? 0}:${p.start?.column ?? 0}-${p.end?.line ?? 0}:${p.end?.column ?? 0}#${index}`;
    }

    function buildLegend(typesInUse) {
      legendEl.innerHTML = '';
      const frag = document.createDocumentFragment();

      // Global controls
      const wsItem = document.createElement('label');
      wsItem.className = 'item';
      const wsCheck = document.createElement('input');
      wsCheck.type = 'checkbox';
      wsCheck.checked = showWhitespace;
      const wsLabel = document.createElement('span');
      wsLabel.textContent = 'Show whitespace';
      wsItem.append(wsCheck, wsLabel);
      wsCheck.addEventListener('change', () => {
        showWhitespace = wsCheck.checked;
        applyWhitespaceVisibility();
      });
      frag.appendChild(wsItem);

      // Enable present types by default
      visibleTypes = new Set(typesInUse);
      for (const type of KNOWN_TYPES) {
        document.body.classList.toggle('type-visible-' + type, visibleTypes.has(type));
      }

      for (const type of KNOWN_TYPES) {
        if (!typesInUse.has(type)) { continue; }
        const item = document.createElement('label');
        item.className = 'item';
        const swatch = document.createElement('span');
        swatch.className = 'swatch';
        swatch.style.background = getComputedStyle(document.documentElement).getPropertyValue('--' + type) || '#333';
        const check = document.createElement('input');
        check.type = 'checkbox';
        check.checked = true;
        check.addEventListener('change', () => {
          if (check.checked) { visibleTypes.add(type); } else { visibleTypes.delete(type); }
          document.body.classList.toggle('type-visible-' + type, check.checked);
          updateCollapseStates();
        });
        const label = document.createElement('span');
        label.textContent = type;
        item.append(check, swatch, label);
        frag.appendChild(item);
      }
      legendEl.appendChild(frag);
    }

    function renderWhitespaceSpans(target, raw) {
      // Render raw text into target span with visible markers for spaces/tabs
      target.textContent = '';
      let buffer = '';
      function flushBuffer() {
        if (buffer) { target.appendChild(document.createTextNode(buffer)); buffer = ''; }
      }
      for (let index = 0; index < raw.length; index += 1) {
        const ch = raw[index];
        if (ch === ' ') {
          flushBuffer();
          const mark = document.createElement('span');
          mark.className = 'ws ws-space';
          mark.textContent = '·';
          target.appendChild(mark);
        } else if (ch === '\t') {
          flushBuffer();
          const mark = document.createElement('span');
          mark.className = 'ws ws-tab';
          mark.textContent = '⇥';
          target.appendChild(mark);
        } else {
          buffer += ch;
        }
      }
      flushBuffer();
    }

    function applyWhitespaceVisibility() {
      const lines = outputEl.querySelectorAll('.line');
      for (const span of lines) {
        if (span.classList.contains('page-break')) { continue; }
        const raw = span.dataset.raw ?? '';
        if (showWhitespace) { renderWhitespaceSpans(span, raw); } else { span.textContent = raw; }
      }
    }

    function setLeftWidth(px) {
      currentLeft = px;
      layoutEl.style.gridTemplateColumns = px + 'px 6px 1fr';
    }

    let dragRaf = null; let pendingX = null; let guideEl = null; let dragPos = null;
    function ensureGuide() {
      if (!guideEl) {
        guideEl = document.createElement('div');
        guideEl.className = 'splitter-guide';
        layoutEl.appendChild(guideEl);
      }
      return guideEl;
    }
    function positionGuide(x) {
      const guide = ensureGuide();
      guide.style.left = x + 'px';
    }
    function clampLeft(x, containerWidth) {
      const splitterWidth = 6; // matches CSS
      const maxLeft = containerWidth - splitterWidth - minRightPx;
      return Math.max(minLeftPx, Math.min(x, maxLeft));
    }
    function startDrag(e) {
      isDragging = true;
      containerRect = layoutEl.getBoundingClientRect();
      document.body.classList.add('dragging');
      e.preventDefault();
      const startLeft = currentLeft == null ? Math.round(containerRect.width * 0.6) : currentLeft;
      const clamped = clampLeft(startLeft, containerRect.width);
      dragPos = clamped;
      positionGuide(clamped);
    }
    function applyDrag(x) {
      const clamped = clampLeft(x, containerRect.width);
      dragPos = clamped;
      positionGuide(clamped);
    }
    function onDrag(e) {
      if (!isDragging) { return; }
      const clientX = e.clientX ?? (e.touches && e.touches[0]?.clientX);
      if (typeof clientX !== 'number') { return; }
      pendingX = clientX - containerRect.left;
      if (dragRaf == null) {
        dragRaf = requestAnimationFrame(() => {
          dragRaf = null;
          if (pendingX != null) { applyDrag(pendingX); pendingX = null; }
        });
      }
    }
    function endDrag() {
      if (!isDragging) { return; }
      isDragging = false;
      document.body.classList.remove('dragging');
      if (dragRaf != null) { cancelAnimationFrame(dragRaf); dragRaf = null; }
      if (dragPos != null) { setLeftWidth(dragPos); }
      pendingX = null; dragPos = null;
      if (guideEl && guideEl.parentNode) { guideEl.parentNode.removeChild(guideEl); }
      guideEl = null;
    }
    // Keyboard resizing for accessibility and precision
    splitterEl.addEventListener('keydown', (event) => {
      const step = (event.shiftKey ? 64 : 16);
      if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
        const dir = event.key === 'ArrowLeft' ? -1 : 1;
        const rect = layoutEl.getBoundingClientRect();
        const next = clampLeft((currentLeft ?? Math.round(rect.width * 0.6)) + dir * step, rect.width);
        setLeftWidth(next);
        event.preventDefault();
      }
    });

    function attachBlockInteractions(blockEl, nodeId) {
      blockEl.addEventListener('mouseenter', () => {
        blockEl.classList.add('hover');
        const node = nodeMap.get(nodeId);
        if (node) { selInfoEl.textContent = `${node.type}`; }
      });
      blockEl.addEventListener('mouseleave', () => {
        blockEl.classList.remove('hover');
        selInfoEl.textContent = selectedNodeId ? selInfoEl.textContent : '';
      });
      blockEl.addEventListener('click', () => selectNode(nodeId));
    }

    function selectNode(nodeId) {
      if (selectedNodeId === nodeId) { return; }
      // Clear previous
      if (selectedNodeId) {
        const prev = nodeContainers.get(selectedNodeId);
        if (prev) { prev.classList.remove('selected'); }
      }
      selectedNodeId = nodeId;
      const container = nodeContainers.get(nodeId);
      if (container) { container.classList.add('selected'); }
      const node = nodeMap.get(nodeId);
      if (node) {
        nodeJsonEl.textContent = JSON.stringify(node, null, 2);
        selInfoEl.textContent = `${node.type}`;
      }
      const containerEl = nodeContainers.get(nodeId);
      if (containerEl) { containerEl.scrollIntoView({ block: 'center', behavior: 'smooth' }); }
      updateCollapseStates();
    }

    function clearSelection() {
      if (!selectedNodeId) { return; }
      const prev = nodeContainers.get(selectedNodeId);
      if (prev) { prev.classList.remove('selected'); }
      selectedNodeId = null;
      nodeJsonEl.textContent = '(none)';
      selInfoEl.textContent = '';
      updateCollapseStates();
    }

    function renderAst(ast) {
      clearRender();
      if (!ast || ast.type !== 'Document' || !Array.isArray(ast.children)) {
        setStatus('Input must be a Document node with children[]', true);
        return;
      }
      currentAst = ast;
      const typesInUse = new Set();
      const frag = document.createDocumentFragment();
      let totalLines = 0;

      // Depth-first render: for each child, render its lines and map lines back to the node
      let nodeSerial = 0;
      function summarize(node, lines) {
        try {
          switch (node.type) {
            case 'Document':
              return `Document: ${node.children?.length ?? 0} blocks`;
            case 'Title':
            case 'SectionTitle':
            case 'Paragraph':
              return (lines[0] ?? '').trim() || node.type;
            case 'IndentedBlock':
              return `IndentedBlock: ${lines.length} line${lines.length !== 1 ? 's' : ''}`;
            case 'List':
              return `List: ${node.items?.length ?? 0} item${(node.items?.length ?? 0) !== 1 ? 's' : ''}`;
            case 'DefinitionList':
              return `DefinitionList: ${node.items?.length ?? 0} term${(node.items?.length ?? 0) !== 1 ? 's' : ''}`;
            case 'TableOfContents':
              return `TableOfContents: ${lines.length} entr${lines.length === 1 ? 'y' : 'ies'}`;
            case 'Figure': {
              // Try to extract a caption if present on the last non-blank line
              let caption = '';
              for (let i = lines.length - 1; i >= 0; i -= 1) {
                const t = (lines[i] || '').trim();
                if (!t) { continue; }
                const m = t.match(/^Figure\s+(\d+)\s*:\s*(.*)$/);
                if (m) {
                  caption = `Figure ${m[1]}: ${m[2]}`.trim();
                }
                break;
              }
              return caption || `Figure: ${lines.length} line${lines.length !== 1 ? 's' : ''}`;
            }
            case 'PageHeader':
              return `Header: ${(node.text ?? '').slice(0, 56)}`;
            case 'PageFooter':
              return `Footer: ${(node.text ?? '').slice(0, 56)}`;
            case 'PageBreak':
              return 'PageBreak';
            case 'BlankLine':
              return 'Blank line';
            default:
              return node.type;
          }
        } catch (_) {
          return node.type || 'Unknown';
        }
      }

      function renderNodeWithMap(node) {
        const lines = renderNode(node);
        const nodeId = makeNodeId(node, nodeSerial++);
        nodeMap.set(nodeId, node);
        nodeLines.set(nodeId, []);
        typesInUse.add(node.type || 'Unknown');

        const block = document.createElement('div');
        block.className = 'block';
        block.dataset.nodeId = nodeId;
        block.dataset.type = node.type || 'Unknown';
        nodeContainers.set(nodeId, block);
        attachBlockInteractions(block, nodeId);

        // Type label badge
        const badge = document.createElement('div');
        badge.className = 'type-badge';
        badge.textContent = node.type || 'Unknown';
        badge.setAttribute('aria-hidden', 'true');
        badge.setAttribute('role', 'presentation');
        block.appendChild(badge);

        // No per-block toggles; collapse is global-only

        for (let index = 0; index < lines.length; index += 1) {
          const text = lines[index];
          const span = document.createElement('span');
          span.className = 'line';
          span.dataset.nodeId = nodeId;
          span.dataset.type = node.type || 'Unknown';
          if ((node.type || 'Unknown') === 'PageBreak') {
            span.classList.add('page-break');
            span.textContent = '␌'; // SYMBOL FOR FORM FEED to visualize page breaks
          } else {
            // Use textContent with white-space: pre to preserve spacing
            span.dataset.raw = text;
            if (showWhitespace) { renderWhitespaceSpans(span, text); } else { span.textContent = text; }
          }
          block.appendChild(span);
          nodeLines.get(nodeId).push(span);
          totalLines += 1;
        }
        // Summary (visible when collapsed)
        const summaryEl = document.createElement('div');
        summaryEl.className = 'summary';
        summaryEl.textContent = summarize(node, lines);
        block.appendChild(summaryEl);

        frag.appendChild(block);
      }

      for (const child of ast.children) {
        renderNodeWithMap(child);
      }

      outputEl.appendChild(frag);
      buildLegend(typesInUse);
      updateCollapseStates();
      applyWhitespaceVisibility();
      setStatus('Rendered ' + totalLines + ' lines.');
    }

    function updateCollapseStates() {
      for (const [nodeId, block] of nodeContainers.entries()) {
        const type = block.dataset.type || 'Unknown';
        const expanded = visibleTypes.has(type);
        block.classList.toggle('collapsed', !expanded);
      }
    }

    function parseAndRender() {
      try {
        setStatus('');
        const text = inputEl.value.trim();
        if (!text) { clearRender(); setStatus('No input'); return; }
        const ast = JSON.parse(text);
        renderAst(ast);
      } catch (e) {
        clearRender();
        setStatus('Parse error: ' + (e && e.message ? e.message : String(e)), true);
      }
    }

    function toCorsProxy(url) {
      return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
    }

    async function fetchUrlAndParse(url) {
      if (!url) { setStatus('Enter a URL to fetch'); return; }
      try {
        const effectiveUrl = toCorsProxy(url);
        setStatus('Fetching: ' + effectiveUrl);
        const response = await fetch(effectiveUrl, { headers: { 'Accept': 'text/plain, */*;q=0.1' } });
        if (!response.ok) {
          throw new Error('HTTP ' + response.status + ' ' + response.statusText);
        }
        const raw = await response.text();
        setStatus('Parsing text...');
        const normalized = raw.replace(/\r?\n/g, '\n').split('\n');
        const cursor = new ArrayCursor(normalized);
        const ast = parse(cursor);
        const json = JSON.stringify(ast, null, 2);
        if (json.length <= MAX_INPUT_PREVIEW_BYTES) {
          inputEl.value = json;
        } else {
          inputEl.value = '';
        }
        renderAst(ast);
        const lineCount = document.querySelectorAll('.output .line').length;
        setStatus('Fetched and parsed. Lines: ' + lineCount + (json.length > MAX_INPUT_PREVIEW_BYTES ? ' (AST JSON omitted from input)' : ''));
      } catch (error) {
        const message = (error && error.message) ? error.message : String(error);
        setStatus('Fetch/parse error: ' + message, true);
      }
    }

    btnRender.addEventListener('click', parseAndRender);
    btnClear.addEventListener('click', () => { inputEl.value = ''; clearRender(); setStatus('Cleared'); });
    btnClearSelection.addEventListener('click', () => { clearSelection(); });
    btnFetchUrl.addEventListener('click', () => { fetchUrlAndParse(urlInput.value.trim()); });
    urlInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); fetchUrlAndParse(urlInput.value.trim()); }
    });
    btnOpenFile.addEventListener('click', () => { fileInput.click(); });
    fileInput.addEventListener('change', async () => {
      const files = fileInput.files;
      if (!files || files.length === 0) { return; }
      const file = files[0];
      await handleLocalFile(file);
      // reset to allow re-selecting the same file
      fileInput.value = '';
    });

    async function handleLocalFile(file) {
      try {
        setStatus('Reading file: ' + file.name);
        const text = await file.text();
        const lower = file.name.toLowerCase();
        if (lower.endsWith('.json')) {
          setStatus('Parsing JSON AST...');
          const ast = JSON.parse(text);
          const json = JSON.stringify(ast, null, 2);
          if (json.length <= MAX_INPUT_PREVIEW_BYTES) { inputEl.value = json; } else { inputEl.value = ''; }
          renderAst(ast);
          const lineCount = document.querySelectorAll('.output .line').length;
          setStatus('Loaded JSON. Lines: ' + lineCount + (json.length > MAX_INPUT_PREVIEW_BYTES ? ' (AST JSON omitted from input)' : ''));
          return;
        }
        setStatus('Parsing text via project parser...');
        const normalized = text.replace(/\r?\n/g, '\n').split('\n');
        const cursor = new ArrayCursor(normalized);
        const ast = parse(cursor);
        const json = JSON.stringify(ast, null, 2);
        if (json.length <= MAX_INPUT_PREVIEW_BYTES) { inputEl.value = json; } else { inputEl.value = ''; }
        renderAst(ast);
        const lineCount = document.querySelectorAll('.output .line').length;
        setStatus('Loaded text file. Lines: ' + lineCount + (json.length > MAX_INPUT_PREVIEW_BYTES ? ' (AST JSON omitted from input)' : ''));
      } catch (error) {
        setStatus('File load/parse error: ' + (error && error.message ? error.message : String(error)), true);
      }
    }
    // Splitter events (mouse + touch)
    splitterEl.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('mouseup', endDrag);
    splitterEl.addEventListener('touchstart', (e) => { startDrag(e); }, { passive: false });
    window.addEventListener('touchmove', (e) => { onDrag(e); }, { passive: false });
    window.addEventListener('touchend', endDrag);
    window.addEventListener('touchcancel', endDrag);
    btnSample.addEventListener('click', () => {
      // RFC-like sample focusing on the Abstract section and realistic header
      const sample = {
        type: 'Document',
        position: { start: { line: 1, column: 1, offset: 0 }, end: { line: 99, column: 1, offset: 9999 } },
        children: [
          // 0: Leading blank line
          { type: 'BlankLine', position: { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } } },

          // 1: Metadata
          { type: 'Metadata', position: { start: { line: 2, column: 1, offset: 1 }, end: { line: 5, column: 1, offset: 200 } }, lines: [
            'Interdum Egestas Typographi Factus (IETF)                  D. Ipsum, Ed.',
            'Rogatio Commentariorum: 9999                                   Lorum Corp',
            'Categoria: Specimen Tractus'
          ]},

          // 2: Blank line before title
          { type: 'BlankLine', position: { start: { line: 6, column: 1, offset: 201 }, end: { line: 6, column: 1, offset: 201 } } },

          // 3: Title
          { type: 'Title', position: { start: { line: 7, column: 1, offset: 202 }, end: { line: 7, column: 60, offset: 260 } }, lines: [
            '                 Lorem Ipsum Dolor Sit Amet'
          ]},

          // 4: Blank line
          { type: 'BlankLine', position: { start: { line: 8, column: 1, offset: 261 }, end: { line: 8, column: 1, offset: 261 } } },

          // 5: SectionTitle - Abstract
          { type: 'SectionTitle', position: { start: { line: 9, column: 1, offset: 262 }, end: { line: 9, column: 9, offset: 270 } }, lines: [
            'Abstract'
          ]},

          // 6: Blank line
          { type: 'BlankLine', position: { start: { line: 10, column: 1, offset: 271 }, end: { line: 10, column: 1, offset: 271 } } },

          // 7: Paragraph - abstract body (acrostic: "THIS IS AN EXAMPLE TEXT")
          { type: 'Paragraph', position: { start: { line: 11, column: 1, offset: 272 }, end: { line: 14, column: 1, offset: 600 } }, lines: [
            '   Tenetur Habitasse Ipsum Sollicitudin Inceptos Sapien',
            '   Aenean Nascetur Eleifend Xiphoides Amet Magnis Posuere Lorem Elit',
            '   Tellus Egestas Xiphos Tristique'
          ]},

          // 8: Blank line
          { type: 'BlankLine', position: { start: { line: 15, column: 1, offset: 601 }, end: { line: 15, column: 1, offset: 601 } } },

          // 9: SectionTitle - Table of Contents
          { type: 'SectionTitle', position: { start: { line: 16, column: 1, offset: 620 }, end: { line: 16, column: 21, offset: 640 } }, lines: [
            'Table of Contents'
          ]},

          // 10: Blank line
          { type: 'BlankLine', position: { start: { line: 17, column: 1, offset: 641 }, end: { line: 17, column: 1, offset: 641 } } },

          // 11: TableOfContents - two entries (one simple, one wrapped)
          { type: 'TableOfContents', position: { start: { line: 18, column: 1, offset: 642 }, end: { line: 21, column: 1, offset: 700 } },
            lines: [
              '   1. Lorem Ipsum ..................................................4',
              '     1.1. Dolor Sit ................................................6',
              '   2. Amet Consectetur',
              '     ...............................................................10'
            ],
            entries: [
              { raw: '   1. Lorem Ipsum ..................................................4', indent: 3, title: '1. Lorem Ipsum', page: 4 },
              { raw: '     1.1. Dolor Sit ................................................6', indent: 5, title: '1.1. Dolor Sit', page: 6 },
              { raw: '   2. Amet Consectetur\n     ...............................................................10', indent: 3, title: '2. Amet Consectetur', page: 10 },
            ]
          },

          // 12: Blank line
          { type: 'BlankLine', position: { start: { line: 22, column: 1, offset: 701 }, end: { line: 22, column: 1, offset: 701 } } },

          // 13: SectionTitle - Notation and Conventions
          { type: 'SectionTitle', position: { start: { line: 23, column: 1, offset: 720 }, end: { line: 23, column: 30, offset: 750 } }, lines: [
            'Notation and Conventions'
          ]},

          // 14: Blank line
          { type: 'BlankLine', position: { start: { line: 24, column: 1, offset: 751 }, end: { line: 24, column: 1, offset: 751 } } },

          // 15: DefinitionList - terms with definitions
          { type: 'DefinitionList', position: { start: { line: 25, column: 1, offset: 752 }, end: { line: 30, column: 1, offset: 820 } }, items: [
            { term: 'Lorum Nomen', termIndent: 3, definitionIndent: 6, lines: [
              'Inanis descriptio de rebus fictis et vacuis.',
            ]},
            { term: 'Ipsum Signum', termIndent: 3, definitionIndent: 6, lines: [
              'Nugae sine sensu ad specimen textus implendum.',
            ]}
          ]},

          // 16: Blank line
          { type: 'BlankLine', position: { start: { line: 31, column: 1, offset: 821 }, end: { line: 31, column: 1, offset: 821 } } },

          // 17: List - unordered list of grant types (with wrapped content)
          { type: 'List', position: { start: { line: 32, column: 1, offset: 840 }, end: { line: 38, column: 1, offset: 900 } }, items: [
            { marker: '-', markerIndent: 3, contentIndent: 5, lines: [
              'Lorum',
            ]},
            { marker: '-', markerIndent: 3, contentIndent: 5, lines: [
              'Ipsum',
            ]},
            { marker: '-', markerIndent: 3, contentIndent: 5, lines: [
              'Dolor',
            ]}
          ]},

          // 18: Blank line
          { type: 'BlankLine', position: { start: { line: 39, column: 1, offset: 901 }, end: { line: 39, column: 1, offset: 901 } } },

          // 19: IndentedBlock - HTTP request example
          { type: 'IndentedBlock', position: { start: { line: 40, column: 5, offset: 920 }, end: { line: 42, column: 1, offset: 960 } }, indent: 4, lines: [
            'Lorem ipsum dolor sit amet, consectetur',
            'adipiscing elit, sed do eiusmod tempor',
            'incididunt ut labore et dolore magna.'
          ]},

          // 20: Blank line
          { type: 'BlankLine', position: { start: { line: 43, column: 1, offset: 961 }, end: { line: 43, column: 1, offset: 961 } } },

          // 21: Figure - ASCII diagram with caption
          { type: 'Figure', position: { start: { line: 44, column: 1, offset: 980 }, end: { line: 51, column: 1, offset: 1040 } }, lines: [
            '   +--------+                               +---------------+',
            '   |        |--(A)- Inanis Nexus ---------> |   Exemplum    |',
            '   | Lorum  |                               |     Ipsum     |',
            '   |        |<-(B)-- Vacuus Rivus --------- |               |',
            '   +--------+                               +---------------+',
            '   Figure 1: Exemplum Textus (specimen)'
          ]},

          // 22: Blank line
          { type: 'BlankLine', position: { start: { line: 52, column: 1, offset: 1041 }, end: { line: 52, column: 1, offset: 1041 } } },

          // 23: PageFooter before a page break
          { type: 'PageFooter', position: { start: { line: 53, column: 1, offset: 1050 }, end: { line: 53, column: 1, offset: 1050 } }, text: 'Lorum                         Specimen Series                        [Page 1]' },

          // 24: PageBreak (form feed)
          { type: 'PageBreak', position: { start: { line: 54, column: 1, offset: 1060 }, end: { line: 54, column: 1, offset: 1060 } } },

          // 25: PageHeader after page break
          { type: 'PageHeader', position: { start: { line: 55, column: 1, offset: 1070 }, end: { line: 55, column: 1, offset: 1070 } }, text: 'RFC 9999                    Lorem Ipsum Dolor Sit Amet' },

          // 26: Blank line
          { type: 'BlankLine', position: { start: { line: 56, column: 1, offset: 1071 }, end: { line: 56, column: 1, offset: 1071 } } },

          // 27: Paragraph - continuation narrative
          { type: 'Paragraph', position: { start: { line: 57, column: 1, offset: 1080 }, end: { line: 58, column: 1, offset: 1120 } }, lines: [
            '   Nulla facit exemplaria; specimina tantum hic leguntur,',
            '   textus omnino fictus et vacuus ad usum ostensionis.'
          ]},

          // 28: Trailing blank line
          { type: 'BlankLine', position: { start: { line: 59, column: 1, offset: 1121 }, end: { line: 59, column: 1, offset: 1121 } } }
        ]
      };
      inputEl.value = JSON.stringify(sample, null, 2);
      parseAndRender();
    });

    // Init: compute 72ch minimum and set default split
    (function initLayout() {
      function computeMinLeftFromCh() {
        const probe = document.createElement('div');
        probe.style.position = 'absolute';
        probe.style.visibility = 'hidden';
        probe.style.width = '72ch';
        probe.style.whiteSpace = 'pre';
        // Match body/output font preference
        probe.style.fontFamily = 'Consolas, monospace';
        probe.style.fontSize = getComputedStyle(document.documentElement).getPropertyValue('--code-size') || '13px';
        document.body.appendChild(probe);
        const width = Math.ceil(probe.getBoundingClientRect().width);
        probe.remove();
        return Math.max(400, width + 32); // account for padding; clamp to reasonable minimum
      }
      minLeftPx = computeMinLeftFromCh();
      const rect = layoutEl.getBoundingClientRect();
      const defaultLeft = Math.max(minLeftPx, Math.round(rect.width * 0.58));
      setLeftWidth(defaultLeft);
      window.addEventListener('resize', () => {
        minLeftPx = computeMinLeftFromCh();
        const rect2 = layoutEl.getBoundingClientRect();
        const splitterWidth = 6; // CSS width
        const maxLeft = rect2.width - splitterWidth - minRightPx;
        const left = currentLeft == null ? defaultLeft : currentLeft;
        setLeftWidth(Math.max(minLeftPx, Math.min(left, maxLeft)));
      });
    })();

    // Auto-render sample on load to show UI
    btnSample.click();
  </script>
</body>
</html>
