<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AST Text Renderer & Inspector</title>
  <style>
    :root {
      --bg: #0b0c0f;
      --panel: #12141a;
      --muted: #a6adbb;
      --text: #e7e9ee;
      --accent: #7aa2f7;
      --danger: #ff6b6b;
      --ok: #22c55e;
      --warn: #f59e0b;
      --border: #1f2430;

      /* Type colors (muted, distinct, cohesive) */
      --Paragraph: rgba(88, 130, 193, 0.22);         /* muted blue */
      --BlankLine: rgba(255, 255, 255, 0.03);        /* near background */
      --IndentedBlock: rgba(149, 110, 186, 0.22);    /* muted purple */
      --Metadata: rgba(210, 160, 96, 0.22);          /* muted orange */
      --Title: rgba(84, 170, 120, 0.22);             /* muted green */
      --SectionTitle: rgba(190, 110, 110, 0.22);     /* muted red */
      /* PageBreak: near-background, distinct from BlankLine */
      --PageBreak: rgba(114, 124, 202, 0.08);
      --PageFooter: rgba(114, 124, 202, 0.08);
      --PageHeader: rgba(114, 124, 202, 0.08);
      --List: rgba(88, 176, 168, 0.22);              /* muted teal */
      --DefinitionList: rgba(142, 180, 102, 0.22);   /* olive */
      --TableOfContents: rgba(176, 146, 100, 0.22);  /* muted amber */
      --Figure: rgba(206, 120, 160, 0.22);           /* muted rose */
      --HttpResponse: rgba(122, 162, 247, 0.18);     /* soft blue tint */
      --HttpRequest: rgba(122, 247, 162, 0.18);      /* soft green tint */
      --Abnf: rgba(247, 162, 122, 0.18);             /* soft orange tint */
      --Document: rgba(255, 255, 255, 0.06);         /* very subtle */

      /* Sizing */
      --code-size: 14px;
      /* Column guide at 73 characters (after 72), monospace ch units */
      --col-guide: 73ch;
      --col-guide-color: rgba(166, 173, 187, 0.25); /* muted */
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: Consolas, monospace;
      color: var(--text);
      background: var(--bg);
    }
    /* drag guide for splitter (no layout during drag) */
    .splitter-guide { position: absolute; top: 0; bottom: 0; width: 6px; background: #1d2a45; border-left: 1px solid var(--border); border-right: 1px solid var(--border); pointer-events: none; z-index: 10; }
    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100%;
    }
    header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }
    header h1 { font-size: 14px; margin: 0; font-weight: 600; letter-spacing: 0.3px; }
    header .left-tools { display: flex; align-items: center; gap: 8px; margin-left: 12px; }
    header .toolbar { margin-left: auto; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    header .toolbar .tool-group { display: flex; align-items: center; gap: 6px; flex-wrap: nowrap; }
    header .toolbar .tool-group button { flex: 0 0 auto; }
    header .toolbar .tool-group + .tool-group { border-left: 1px solid var(--border); padding-left: 10px; }
    button, .btn {
      background: #1b2331;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    button:disabled { opacity: 0.6; cursor: default; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    /* Loading indicator in buttons */
    button.loading::before, .btn.loading::before {
      content: '';
      display: inline-block;
      width: 10px; height: 10px;
      margin-right: 6px;
      border: 2px solid #2b3445;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      vertical-align: -1px;
    }
    /* Ensure all UI controls render in monospace */
    button, .btn, input, select, textarea, label { font-family: inherit; font-variant-ligatures: none; }
    button:hover { border-color: #2b3445; }
    .layout {
      display: grid;
      position: relative;
      grid-template-columns: var(--left-width, 60%) 6px 1fr; /* left | splitter | right */
      gap: 0;
      height: 100%;
    }
    .splitter {
      background: #101521;
      border-left: 1px solid var(--border);
      border-right: 1px solid var(--border);
      cursor: col-resize;
    }
    .splitter:hover { background: #162033; }
    body.dragging .splitter { background: #1d2a45; }
    body.dragging { user-select: none; cursor: col-resize; }
    .panel { display: flex; flex-direction: column; border-right: 1px solid var(--border); }
    .panel:last-child { border-right: none; }
    .panel header { border: none; border-bottom: 1px solid var(--border); }
    .panel .body { flex: 1; min-height: 0; }

    .input-wrap { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .input-controls { display: flex; align-items: center; gap: 8px; padding: 8px 12px; }
    textarea {
      width: 100%; height: 100%; box-sizing: border-box; resize: none; outline: none;
      border: 1px solid var(--border); background: #0c111b; color: var(--text);
      padding: 12px; font-size: var(--code-size); line-height: 1.6;
      border-radius: 8px;
      tab-size: 4;
    }
    textarea:focus {
      border-color: #2b3445;
      box-shadow: inset 0 0 0 1px #2b3445, 0 0 0 2px rgba(122,162,247,0.15);
    }

    .render-wrap { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .legend { display: flex; flex-wrap: wrap; gap: 6px 10px; padding: 8px 12px; border-bottom: 1px solid var(--border); background: #0f1320; }
    .legend .item { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; color: var(--muted); cursor: pointer; user-select: none; font-family: inherit; }
    .legend .swatch { width: 12px; height: 12px; border-radius: 3px; outline: 1px solid var(--border); }
    .legend .item input { margin: 0; }

    /* Types popover for scalable type toggles */
    .types-popover {
      position: absolute;
      z-index: 20;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      min-width: 260px;
      max-width: 520px;
      max-height: 60vh;
      overflow: hidden;
      display: none;
    }
    .types-popover.open { display: block; }
    .types-popover header { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: #0f1320; border-bottom: 1px solid var(--border); }
    .types-popover header .title { font-size: 12px; font-weight: 600; }
    .types-popover .controls { display: flex; align-items: center; gap: 8px; padding: 8px 10px; border-bottom: 1px solid var(--border); }
    .types-popover .controls .spacer { flex: 1 1 auto; }
    .types-popover .filter { width: 100%; box-sizing: border-box; padding: 6px 8px; border-radius: 6px; border: 1px solid var(--border); background: #0c111b; color: var(--text); font-family: inherit; font-size: 12px; }
    .types-popover .list { padding: 8px 10px; overflow: auto; max-height: 44vh; display: grid; grid-template-columns: 1fr; gap: 6px; }
    .types-popover .list .item { display: flex; align-items: center; gap: 6px; }
    .types-popover .list .item .swatch { width: 12px; height: 12px; border-radius: 3px; outline: 1px solid var(--border); }
    .types-popover .footer { display: flex; align-items: center; justify-content: flex-end; gap: 8px; padding: 8px 10px; border-top: 1px solid var(--border); }
  
    .layout, .panel { min-height: 0; }
    .render-area { position: relative; height: 100%; overflow-y: scroll; overflow-x: auto; contain: paint; }
    .output {
      position: relative; margin: 0; padding: 8px 12px; background: transparent;
      border: none; color: var(--text); white-space: pre; line-height: 1.6; font-size: var(--code-size);
      font-family: Consolas, monospace;
      font-variant-ligatures: none;
    }
    /* Line with fixed-width left index gutter, line-number gutter, and content */
    .output .line { display: grid; grid-template-columns: var(--ix-width, 3ch) var(--ln-width, 4ch) 1fr; align-items: baseline; position: relative; }
    .output .line .ix { color: var(--muted); opacity: 0.7; text-align: right; padding-right: 6px; user-select: none; -webkit-user-select: none; -moz-user-select: none; }
    .output .line .ln { color: var(--muted); opacity: 0.7; text-align: right; padding-right: 8px; user-select: none; -webkit-user-select: none; -moz-user-select: none; }
    .output .line .content { display: inline-block; padding: 0 6px; position: relative; }
    .output .line::selection { background: rgba(122, 162, 247, 0.35); }
    /* Visible whitespace markers: overlay via ::before so actual whitespace remains copyable */
    .output .line .ws { position: relative; display: inline-block; color: var(--muted); opacity: 0.7; }
    .output .line .ws::before { position: absolute; left: 0; right: 0; top: 50%; transform: translateY(-50%); text-align: center; color: var(--muted); opacity: 0.7; pointer-events: none; font-size: 8px; line-height: 1; }
    .output .line .ws.ws-space::before { content: '·'; font-size: 12px; }
    .output .line .ws.ws-tab::before { content: '⇥'; }
    /* Ensure blank lines occupy vertical space without inserting spaces */
    .output .line:empty::before { content: "\200B"; }
    /* Column guide at 72 characters (from content start). Use absolute overlay so it persists with type tints. */
    .output .line::after {
      content: '';
      position: absolute;
      top: 0; bottom: 0;
      left: calc(var(--ix-width, 3ch) + var(--ln-width, 4ch) + var(--col-guide));
      width: 0;
      border-left: 1px solid var(--col-guide-color);
      pointer-events: none;
    }
    /* Validation highlighting for errors (e.g., over-72-char lines) */
    .output .line.error-too-long {
      /* stronger overall tint */
      background-color: rgba(255, 59, 59, 0.18);
    }
    /* Bold left-edge danger stripe for instant recognition */
    .output .line.error-too-long::before {
      content: '';
      position: absolute;
      top: 0; bottom: 0;
      left: 0;
      width: 6px;
      background: var(--danger);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.2) inset;
      pointer-events: none;
    }
    /* Strong overlay beyond the 72-char column with warning stripes */
    .output .line.error-too-long .content::after {
      content: '';
      position: absolute;
      top: 0; bottom: 0;
      left: var(--col-guide);
      right: 0;
      background: repeating-linear-gradient(45deg,
        rgba(255, 107, 107, 0.45), rgba(255, 107, 107, 0.45) 8px,
        rgba(255, 107, 107, 0.20) 8px, rgba(255, 107, 107, 0.20) 16px
      );
      pointer-events: none;
    }
    /* Make the column guide bold and red on error lines */
    .output .line.error-too-long::after {
      border-left-color: var(--danger);
      border-left-width: 2px;
    }
    .output .line.error-too-long .ln,
    .output .line.error-too-long .ix {
      color: var(--danger);
      font-weight: 600;
    }
    /* Add an inline alert badge in the index gutter */
    .output .line.error-too-long .ix::after {
      content: '⛔';
      margin-left: 4px;
      font-size: 11px;
      color: var(--danger);
      opacity: 0.95;
    }
    .output .line.flash { outline: 3px solid var(--accent); outline-offset: -1px; background-color: rgba(122, 162, 247, 0.10); }
    /* Visualize page breaks explicitly */
    .output .line.page-break { color: var(--muted); }

    /* Node block container to group multi-line nodes for unified outlines */
    .output .block {
      display: block;
      position: relative;
      /* Always show a subtle border around rendered items */
      border: 1px solid var(--border);
      border-radius: 0;
      margin: 2px 0;
      /* Hint to the browser that outline may change on hover/selection */
      will-change: outline;
    }
    /* Make labels non-selectable so they don't end up in clipboard */
    .output .block .type-badge { user-select: none; -webkit-user-select: none; -moz-user-select: none; pointer-events: none; }
    .output .block .summary { display: none; color: var(--muted); padding-left: 8px; }
    /* When collapsed, hide the entire block to focus only on checked types */
    .output .block.collapsed { display: none; }
    /* Hover uses pure CSS to avoid JS-induced lag */
    .output .block:hover { outline: 1px solid #2d3b59; outline-offset: -1px; }
    .output .block.selected { outline: 2px solid var(--accent); outline-offset: -1px; }

    /* Small type label at top-right of each block */
    .output .block .type-badge {
      position: absolute;
      top: 0;
      right: 0;
      font-size: 10px;
      line-height: 1;
      color: var(--text);
      background: var(--border);
      border: 1px solid var(--border);
      border-radius: 0;
      padding: 2px 4px;
      pointer-events: none; /* do not block clicks on the block */
      opacity: 0.9;
    }

    /* Badges share the same background as borders (override any per-type tints) */
    .output .block[data-type] .type-badge { background: var(--border); }

    /* Highlight overlays via background on lines for the node’s type (gated by visibility classes) */
    .type-visible-Paragraph .output .line[data-type="Paragraph"] { background: var(--Paragraph); }
    .type-visible-BlankLine .output .line[data-type="BlankLine"] { background: var(--BlankLine); }
    .type-visible-IndentedBlock .output .line[data-type="IndentedBlock"] { background: var(--IndentedBlock); }
    .type-visible-Metadata .output .line[data-type="Metadata"] { background: var(--Metadata); }
    .type-visible-Title .output .line[data-type="Title"] { background: var(--Title); }
    .type-visible-SectionTitle .output .line[data-type="SectionTitle"] { background: var(--SectionTitle); }
    .type-visible-PageBreak .output .line[data-type="PageBreak"] { background: var(--PageBreak); }
    .type-visible-PageFooter .output .line[data-type="PageFooter"] { background: var(--PageFooter); }
    .type-visible-PageHeader .output .line[data-type="PageHeader"] { background: var(--PageHeader); }
    .type-visible-List .output .line[data-type="List"] { background: var(--List); }
    .type-visible-DefinitionList .output .line[data-type="DefinitionList"] { background: var(--DefinitionList); }
    .type-visible-TableOfContents .output .line[data-type="TableOfContents"] { background: var(--TableOfContents); }
    .type-visible-Figure .output .line[data-type="Figure"] { background: var(--Figure); }
    .type-visible-HttpResponse .output .line[data-type="HttpResponse"] { background: var(--HttpResponse); }
    .type-visible-HttpRequest .output .line[data-type="HttpRequest"] { background: var(--HttpRequest); }
    .type-visible-Abnf .output .line[data-type="Abnf"] { background: var(--Abnf); }
    .type-visible-Document .output .line[data-type="Document"] { background: var(--Document); }

    /* Hover and selection are now applied to .block containers */

    .details { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .details .header { display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-bottom: 1px solid var(--border); background: #0f1320; }
    .details .header .title { font-size: 12px; font-weight: 600; margin: 0; letter-spacing: 0.2px; }
    .details .content { height: 100%; overflow: auto; }
    .details pre { margin: 0; padding: 12px; white-space: pre; font-size: 12px; line-height: 1.45; }

    .status { font-size: 12px; color: var(--muted); padding: 8px 12px; border-top: 1px solid var(--border); }
    .status.loading::before {
      content: '';
      display: inline-block;
      width: 10px; height: 10px;
      margin-right: 8px;
      border: 2px solid #2b3445;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      vertical-align: -1px;
    }
    .error { color: var(--danger); }

    /* Modal backdrop for JSON dialog */
    dialog::backdrop { background: rgba(5, 8, 15, 0.6); }

    /* Activity log styles */
    .log { border-top: 1px solid var(--border); }
    .log summary { list-style: none; cursor: pointer; padding: 6px 12px; color: var(--muted); background: #0f1320; user-select: none; }
    .log summary::marker { display: none; }
    .log pre { margin: 0; padding: 8px 12px; font-size: 12px; line-height: 1.45; color: var(--muted); max-height: 200px; overflow: auto; white-space: pre; }

    /* Validation panel styles */
    .validation { border-top: 1px solid var(--border); }
    .validation summary { list-style: none; cursor: pointer; padding: 6px 12px; color: var(--muted); background: #0f1320; user-select: none; display: flex; gap: 8px; align-items: baseline; }
    .validation summary::marker { display: none; }
    .validation .content { padding: 6px 12px; display: grid; gap: 6px; max-height: 240px; overflow: auto; }
    .validation .error-item { display: flex; gap: 8px; align-items: baseline; font-size: 12px; color: var(--text); }
    .validation .error-item .loc { color: var(--danger); min-width: 10ch; }
    .validation .error-item .msg { color: var(--muted); }
    .validation .error-item .jump { margin-left: auto; }
    .validation .btn-link { background: transparent; color: var(--accent); border: none; padding: 0; cursor: pointer; font-size: 12px; text-decoration: underline; }
  </style>
</head>
<body>
  <div class="app" style="grid-template-rows: auto auto 1fr auto; height: 100vh;">
    <header style="gap: 16px; align-items: center;">
      <h1>AST Text Renderer & Inspector</h1>
      <div class="left-tools">
        <button id="btnTypes" title="Show/hide node types">Filter</button>
      </div>
      <div class="toolbar">
        <!-- Source: URL first for common case -->
        <div class="tool-group" style="flex: 1 1 auto; min-width: 360px;">
          <input id="urlInput" type="url" placeholder="https://www.rfc-editor.org/rfc/rfc6749.txt" value="https://www.rfc-editor.org/rfc/rfc6749.txt" style="flex: 2 1 640px; min-width: 360px; max-width: 70vw; padding: 6px 8px; border-radius: 6px; border: 1px solid var(--border); background: #0c111b; color: var(--text);" />
          <button id="btnFetchUrl" title="Fetch URL and parse as RFC text">From URL</button>
        </div>
        <!-- Source: local file -->
        <div class="tool-group">
          <button id="btnOpenFile" title="Select a local file (.txt or .json)">From File</button>
          <input id="fileInput" type="file" accept=".txt,.json,text/plain,application/json" style="display:none" />
        </div>
        <!-- Source: JSON and Clipboard -->
        <div class="tool-group">
          <button id="btnOpenJsonDialog" title="Open JSON input form">From JSON</button>
          <button id="btnFromClipboard" title="Read text from clipboard and parse">From Clipboard</button>
        </div>
        <!-- Utilities -->
        <div class="tool-group">
          <button id="btnSample" title="Insert a small sample AST">Load Sample</button>
          <button id="btnClear">Clear</button>
        </div>
      </div>
    </header>

    <div class="legend" id="legend" style="display:none"></div>

    <div class="layout" id="mainLayout" style="height: 100%; min-height: 0;">
      <div class="panel render-panel" style="border-right: 1px solid var(--border); min-height: 0;">
        <div class="render-area" id="renderArea" style="height: 100%; min-height: 0;">
          <pre class="output" id="output"></pre>
        </div>
      </div>
      <div class="splitter" id="splitter" aria-label="Resize panels" role="separator" aria-orientation="vertical" tabindex="0"></div>
      <div class="panel" style="min-height: 0;">
        <div class="details">
          <div class="header">
            <span class="title">Selected Node(s)</span>
            <span id="selInfo" class="muted"></span>
            <div style="margin-left: auto; display:flex; gap: 8px;">
              <button id="btnClearSelection">Clear Selection</button>
            </div>
          </div>
          <div class="content">
            <textarea id="nodeEditor" placeholder="(Select a node to edit JSON)" spellcheck="false" style="width:100%; height:100%; box-sizing:border-box; resize:none; outline:none; border: 1px solid var(--border); background:#0c111b; color:var(--text); padding:12px; font-size: var(--code-size); line-height:1.6; border-radius:8px; tab-size:4;" disabled></textarea>
          </div>
        </div>
      </div>
    </div>

    <div class="status" id="status"></div>
    <details id="validationPanel" class="validation">
      <summary><span id="validationSummary">Validation</span></summary>
      <div id="validationContent" class="content"></div>
    </details>
    <details id="logPanel" class="log">
      <summary>Activity Log</summary>
      <pre id="statusLog"></pre>
    </details>
  </div>

  <!-- Types Popover (scalable alternative to checkbox row) -->
  <div id="typesPopover" class="types-popover" role="dialog" aria-label="Node Types" aria-modal="false">
    <header><span class="title">Node Types</span></header>
    <div class="controls">
      <button id="btnTypesAll" class="btn">All</button>
      <button id="btnTypesNone" class="btn">None</button>
      <span class="spacer"></span>
      <label class="item" style="display:flex; align-items:center; gap:6px;">
        <input id="chkShowWhitespace" type="checkbox" />
        <span>Show whitespace</span>
      </label>
    </div>
    <div style="padding: 8px 10px;">
      <input id="typesFilter" class="filter" placeholder="Filter types" />
    </div>
    <div id="typesList" class="list"></div>
  </div>

  <!-- JSON Input Dialog -->
  <dialog id="jsonDialog" style="border: 1px solid var(--border); background: var(--panel); color: var(--text); padding: 0; border-radius: 8px; width: min(960px, 92vw);">
    <form method="dialog" style="display:flex; flex-direction: column; max-height: 80vh;">
      <header style="display:flex; align-items:center; gap: 8px; padding: 8px 12px; border-bottom: 1px solid var(--border); background: #0f1320;">
        <strong style="font-size: 12px;">Paste JSON AST</strong>
        <small class="muted">Paste a Document node</small>
      </header>
      <div style="padding: 8px 12px; display:flex; flex-direction: column; gap: 8px;">
        <label for="input" class="muted">AST JSON</label>
        <textarea id="input" rows="12" placeholder='{"type":"Document","children":[...]}' style="width: 100%; box-sizing: border-box; resize: vertical; outline: none; border: 1px solid var(--border); background: #0c111b; color: var(--text); padding: 12px; font-size: var(--code-size); line-height: 1.6; border-radius: 8px; tab-size: 4;"></textarea>
      </div>
      <footer style="display:flex; gap: 8px; padding: 8px 12px; border-top: 1px solid var(--border); background: #0f1320;">
        <button value="cancel">Cancel</button>
        <button id="btnDialogLoad" value="default">Load</button>
      </footer>
    </form>
  </dialog>

  <script type="module">
    import { renderNode } from './dist/Tree/Render/RenderNode.js';
    import { parse } from './dist/Tree/Parser.js';
    import { ArrayCursor } from './dist/Utils/ArrayCursor.js';

    // UI logic
    const inputEl = document.getElementById('input');
    const outputEl = document.getElementById('output');
    const statusEl = document.getElementById('status');
    const logPanelEl = document.getElementById('logPanel');
    const statusLogEl = document.getElementById('statusLog');
    const validationPanelEl = document.getElementById('validationPanel');
    const validationSummaryEl = document.getElementById('validationSummary');
    const validationContentEl = document.getElementById('validationContent');
    const typesPopover = document.getElementById('typesPopover');
    const typesListEl = document.getElementById('typesList');
    const btnTypes = document.getElementById('btnTypes');
    const btnTypesAll = document.getElementById('btnTypesAll');
    const btnTypesNone = document.getElementById('btnTypesNone');
    const typesFilterEl = document.getElementById('typesFilter');
    const chkShowWhitespace = document.getElementById('chkShowWhitespace');
    const nodeEditor = document.getElementById('nodeEditor');
    const selInfoEl = document.getElementById('selInfo');

    const btnSample = document.getElementById('btnSample');
    const btnClear = document.getElementById('btnClear');
    const btnClearSelection = document.getElementById('btnClearSelection');
    const urlInput = document.getElementById('urlInput');
    const btnFetchUrl = document.getElementById('btnFetchUrl');
    const btnOpenFile = document.getElementById('btnOpenFile');
    const fileInput = document.getElementById('fileInput');
    const layoutEl = document.getElementById('mainLayout');
    const renderAreaEl = document.getElementById('renderArea');
    const splitterEl = document.getElementById('splitter');
    const btnFromClipboard = document.getElementById('btnFromClipboard');
    const btnOpenJsonDialog = document.getElementById('btnOpenJsonDialog');
    const jsonDialog = document.getElementById('jsonDialog');
    const btnDialogLoad = document.getElementById('btnDialogLoad');

    let currentAst = null;
    let nodeMap = new Map(); // nodeId -> node
    let nodeLines = new Map(); // nodeId -> array of line elements
    let nodeContainers = new Map(); // nodeId -> block container element
    let nodeOrder = []; // nodeIds in render order
    let nodeIndex = new Map(); // nodeId -> index in nodeOrder
    let visibleTypes = new Set(); // which types are toggled visible
    let selectedNodeIds = new Set();
    let selectionAnchorId = null; // last anchor for Shift+Click range
    let collapseAll = false;
    let showWhitespace = true; // whether to visualize spaces and tabs
    let isDragging = false;
    let containerRect = null;
    let minLeftPx = 740; // will be recomputed based on 72ch
    let minRightPx = 240; // slightly smaller JSON panel for compactness
    let currentLeft = null;
    let suppressEditorUpdate = false; // do not overwrite editor while applying edits

    const KNOWN_TYPES = [
      'Document','Title','SectionTitle','Metadata','Paragraph','IndentedBlock','List','DefinitionList','TableOfContents','Figure','HttpResponse','HttpRequest','Abnf','BlankLine','PageHeader','PageFooter','PageBreak'
    ];
    const MAX_INPUT_PREVIEW_BYTES = 1_000_000;
    const MAX_LINE_LENGTH = 72; // validator threshold

    // Lightweight activity log for status changes and durations
    const statusLog = [];
    let activeOperation = null; // { text, startedAtMs, startedIso }
    const MAX_LOG_LINES = 400;

    function pad2(n) { return n.toString().padStart(2, '0'); }
    function formatClock(date) {
      const hh = pad2(date.getHours());
      const mm = pad2(date.getMinutes());
      const ss = pad2(date.getSeconds());
      const ms = date.getMilliseconds().toString().padStart(3, '0');
      return `${hh}:${mm}:${ss}.${ms}`;
    }
    function appendLogLine(line) {
      // Maintain an in-memory list and update the UI efficiently
      statusLog.push(line);
      if (statusLog.length > MAX_LOG_LINES) { statusLog.shift(); }
      statusLogEl.textContent = statusLog.join('\n');
      // Auto-scroll to bottom when open
      if (logPanelEl.open) { statusLogEl.scrollTop = statusLogEl.scrollHeight; }
    }
    function recordStatus(text, isError, isLoading) {
      const nowDate = new Date();
      const nowClock = formatClock(nowDate);
      const nowMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const label = (text || '').trim();

      // Start of an operation
      if (isLoading) {
        if (activeOperation != null) {
          // Implicitly complete the previous operation before starting the next stage
          const elapsedMs = Math.max(0, Math.round(nowMs - activeOperation.startedAtMs));
          appendLogLine(`[${nowClock}] ✔ Done: "${activeOperation.text}" in ${elapsedMs} ms`);
        }
        activeOperation = { text: label || '(loading)', startedAtMs: nowMs, startedIso: nowDate.toISOString() };
        appendLogLine(`[${nowClock}] ▶ Start: "${activeOperation.text}"`);
        return;
      }

      // End of an operation (success or error), if any
      if (activeOperation != null) {
        const elapsedMs = Math.max(0, Math.round(nowMs - activeOperation.startedAtMs));
        const outcome = isError ? '✖ Error' : '✔ Done';
        const endLabel = label && label !== activeOperation.text ? ` → ${label}` : '';
        appendLogLine(`[${nowClock}] ${outcome}: "${activeOperation.text}"${endLabel} in ${elapsedMs} ms`);
        activeOperation = null;
        return;
      }

      // Plain status change (no active operation)
      const prefix = isError ? '!' : '•';
      appendLogLine(`[${nowClock}] ${prefix} ${label}`);
    }

    function setStatus(text, isError=false, isLoading=false) {
      statusEl.textContent = text || '';
      statusEl.classList.toggle('error', !!isError);
      statusEl.classList.toggle('loading', !!isLoading);
      recordStatus(text || '', !!isError, !!isLoading);
    }

    function escapeHtml(s) {
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function clearRender() {
      outputEl.innerHTML = '';
      typesListEl.innerHTML = '';
      nodeMap.clear();
      nodeLines.clear();
      nodeContainers.clear();
      nodeOrder = [];
      nodeIndex.clear();
      selectedNodeIds.clear();
      selectionAnchorId = null;
      try { nodeEditor.value = ''; nodeEditor.disabled = true; } catch (_) {}
      selInfoEl.textContent = '';
    }

    function makeNodeId(node, index) {
      // Simple, stable key without position: type#index
      return `${node.type || 'Unknown'}#${index}`;
    }

    function buildLegend(typesInUse) {
      // Global controls are in the popover header; keep checkbox state in sync
      chkShowWhitespace.checked = showWhitespace;

      // Enable present types by default
      visibleTypes = new Set(typesInUse);
      for (const type of KNOWN_TYPES) {
        document.body.classList.toggle('type-visible-' + type, visibleTypes.has(type));
      }

      for (const type of KNOWN_TYPES) {
        if (!typesInUse.has(type)) { continue; }
        const item = document.createElement('label');
        item.className = 'item';
        item.dataset.type = type;
        const check = document.createElement('input');
        check.type = 'checkbox';
        check.checked = true;
        const swatch = document.createElement('span');
        swatch.className = 'swatch';
        swatch.style.background = getComputedStyle(document.documentElement).getPropertyValue('--' + type) || '#333';
        const label = document.createElement('span');
        label.textContent = type;
        check.addEventListener('change', () => {
          if (check.checked) { visibleTypes.add(type); } else { visibleTypes.delete(type); }
          document.body.classList.toggle('type-visible-' + type, check.checked);
          updateCollapseStates();
          ensureSelectedVisible(true);
        });
        item.append(check, swatch, label);
        typesListEl.appendChild(item);
      }
    }

    function renderWhitespaceSpans(target, raw) {
      // Render raw text into target span with visible markers overlaid via CSS
      target.textContent = '';
      let buffer = '';
      function flushBuffer() {
        if (buffer) { target.appendChild(document.createTextNode(buffer)); buffer = ''; }
      }
      for (let index = 0; index < raw.length; index += 1) {
        const ch = raw[index];
        if (ch === ' ') {
          flushBuffer();
          const mark = document.createElement('span');
          mark.className = 'ws ws-space';
          mark.textContent = ' ';
          target.appendChild(mark);
        } else if (ch === '\t') {
          flushBuffer();
          const mark = document.createElement('span');
          mark.className = 'ws ws-tab';
          mark.textContent = '\t';
          target.appendChild(mark);
        } else {
          buffer += ch;
        }
      }
      flushBuffer();
    }

    function applyWhitespaceVisibility() {
      const contents = outputEl.querySelectorAll('.line .content');
      for (const content of contents) {
        const line = content.closest('.line');
        if (line && line.classList.contains('page-break')) { continue; }
        const raw = content.dataset.raw ?? '';
        if (showWhitespace) { renderWhitespaceSpans(content, raw); } else { content.textContent = raw; }
      }
    }

    // Schedule whitespace rendering to avoid blocking initial paint
    function scheduleWhitespaceRender() {
      const runner = () => applyWhitespaceVisibility();
      const ric = (window && (window.requestIdleCallback || null));
      if (typeof ric === 'function') {
        ric(runner, { timeout: 250 });
      } else {
        setTimeout(runner, 0);
      }
    }

    // Types popover helpers
    function positionTypesPopover() {
      const btn = btnTypes;
      const pop = typesPopover;
      const rect = btn.getBoundingClientRect();
      const scrollX = window.scrollX || window.pageXOffset;
      const scrollY = window.scrollY || window.pageYOffset;
      const left = Math.min(rect.left + scrollX, (window.innerWidth + scrollX) - pop.offsetWidth - 12);
      const top = rect.bottom + scrollY + 6;
      pop.style.left = left + 'px';
      pop.style.top = top + 'px';
    }
    function openTypesPopover() {
      typesPopover.classList.add('open');
      positionTypesPopover();
      typesFilterEl.value = '';
      filterTypes('');
      document.addEventListener('click', onDocClickCloseTypes, true);
      window.addEventListener('resize', positionTypesPopover);
      window.addEventListener('scroll', positionTypesPopover, true);
    }
    function closeTypesPopover() {
      typesPopover.classList.remove('open');
      document.removeEventListener('click', onDocClickCloseTypes, true);
      window.removeEventListener('resize', positionTypesPopover);
      window.removeEventListener('scroll', positionTypesPopover, true);
    }
    function onDocClickCloseTypes(e) {
      if (!typesPopover.classList.contains('open')) { return; }
      const target = e.target;
      if (target === btnTypes || btnTypes.contains(target)) { return; }
      if (typesPopover.contains(target)) { return; }
      closeTypesPopover();
    }
    function filterTypes(query) {
      const q = query.trim().toLowerCase();
      const items = typesListEl.querySelectorAll('label.item');
      for (const item of items) {
        const name = (item.querySelector('span:last-child')?.textContent || '').toLowerCase();
        item.style.display = name.includes(q) ? '' : 'none';
      }
    }

    function setLeftWidth(px) {
      currentLeft = px;
      layoutEl.style.gridTemplateColumns = px + 'px 6px 1fr';
    }

    let dragRaf = null; let pendingX = null; let guideEl = null; let dragPos = null;
    function ensureGuide() {
      if (!guideEl) {
        guideEl = document.createElement('div');
        guideEl.className = 'splitter-guide';
        layoutEl.appendChild(guideEl);
      }
      return guideEl;
    }
    function positionGuide(x) {
      const guide = ensureGuide();
      guide.style.left = x + 'px';
    }
    function clampLeft(x, containerWidth) {
      const splitterWidth = 6; // matches CSS
      const maxLeft = containerWidth - splitterWidth - minRightPx;
      return Math.max(minLeftPx, Math.min(x, maxLeft));
    }
    function startDrag(e) {
      isDragging = true;
      containerRect = layoutEl.getBoundingClientRect();
      document.body.classList.add('dragging');
      e.preventDefault();
      const startLeft = currentLeft == null ? Math.round(containerRect.width * 0.5) : currentLeft;
      const clamped = clampLeft(startLeft, containerRect.width);
      dragPos = clamped;
      positionGuide(clamped);
    }
    function applyDrag(x) {
      const clamped = clampLeft(x, containerRect.width);
      dragPos = clamped;
      positionGuide(clamped);
    }
    function onDrag(e) {
      if (!isDragging) { return; }
      const clientX = e.clientX ?? (e.touches && e.touches[0]?.clientX);
      if (typeof clientX !== 'number') { return; }
      pendingX = clientX - containerRect.left;
      if (dragRaf == null) {
        dragRaf = requestAnimationFrame(() => {
          dragRaf = null;
          if (pendingX != null) { applyDrag(pendingX); pendingX = null; }
        });
      }
    }
    function endDrag() {
      if (!isDragging) { return; }
      isDragging = false;
      document.body.classList.remove('dragging');
      if (dragRaf != null) { cancelAnimationFrame(dragRaf); dragRaf = null; }
      if (dragPos != null) { setLeftWidth(dragPos); }
      pendingX = null; dragPos = null;
      if (guideEl && guideEl.parentNode) { guideEl.parentNode.removeChild(guideEl); }
      guideEl = null;
    }
    // Keyboard resizing for accessibility and precision
    splitterEl.addEventListener('keydown', (event) => {
      const step = (event.shiftKey ? 64 : 16);
      if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
        const dir = event.key === 'ArrowLeft' ? -1 : 1;
        const rect = layoutEl.getBoundingClientRect();
        const next = clampLeft((currentLeft ?? Math.round(rect.width * 0.5)) + dir * step, rect.width);
        setLeftWidth(next);
        event.preventDefault();
      }
    });

    function attachBlockInteractions(blockEl, nodeId) {
      // No per-block listeners; we delegate clicks from the output container.
    }
    function updateSelectionView() {
      for (const [id, el] of nodeContainers.entries()) {
        el.classList.toggle('selected', selectedNodeIds.has(id));
      }
      if (selectedNodeIds.size === 0) {
        try { nodeEditor.value = ''; nodeEditor.disabled = true; } catch (_) {}
        selInfoEl.textContent = '';
        return;
      }
      if (selectedNodeIds.size === 1) {
        const onlyId = Array.from(selectedNodeIds)[0];
        const node = nodeMap.get(onlyId);
        if (node) {
          try {
            nodeEditor.disabled = false;
            if (!suppressEditorUpdate && document.activeElement !== nodeEditor) {
              nodeEditor.value = JSON.stringify(node, null, 2);
            }
          } catch (_) {}
          selInfoEl.textContent = `${node.type}`;
          ensureSelectedVisible(false);
        }
        return;
      }
      const nodes = [];
      for (const [id] of nodeContainers.entries()) {
        if (selectedNodeIds.has(id)) {
          const node = nodeMap.get(id);
          if (node) { nodes.push(node); }
        }
      }
      try {
        nodeEditor.disabled = false;
        if (!suppressEditorUpdate && document.activeElement !== nodeEditor) {
          nodeEditor.value = JSON.stringify(nodes, null, 2);
        }
      } catch (_) {}
      selInfoEl.textContent = `${nodes.length} selected`;
    }

    // Apply edits from the right-panel editor to the current AST and re-render
    function applyNodeEdits(parsedValue) {
      if (!currentAst || !Array.isArray(currentAst.children)) { return; }
      if (selectedNodeIds.size === 0) { return; }
      // Capture prior visibility and selection to restore after re-render
      const prevVisible = new Set(visibleTypes);
      const prevSelectionIndices = Array.from(selectedNodeIds).map(id => nodeIndex.get(id)).filter(i => typeof i === 'number').sort((a, b) => a - b);
      // Capture editor focus and caret/scroll position to restore after re-render
      const hadFocus = (document.activeElement === nodeEditor);
      const prevStart = (typeof nodeEditor.selectionStart === 'number') ? nodeEditor.selectionStart : 0;
      const prevEnd = (typeof nodeEditor.selectionEnd === 'number') ? nodeEditor.selectionEnd : prevStart;
      const prevScrollTop = nodeEditor.scrollTop || 0;

      // Build mapping of selected indices in render order
      const selectedIdsInOrder = nodeOrder.filter(id => selectedNodeIds.has(id));
      const selectedIndices = selectedIdsInOrder.map(id => nodeIndex.get(id));

      // Helper to validate a node-like object
      function isNodeLike(obj) {
        return obj && typeof obj === 'object' && typeof obj.type === 'string';
      }

      if (selectedIndices.length === 1 && !Array.isArray(parsedValue)) {
        if (!isNodeLike(parsedValue)) { throw new Error('Edited JSON must be a node object with a "type" string'); }
        const idx = selectedIndices[0];
        currentAst.children[idx] = parsedValue;
        updateRenderedNodeAt(idx, parsedValue);
      } else if (selectedIndices.length > 1 && Array.isArray(parsedValue)) {
        if (parsedValue.length !== selectedIndices.length) { throw new Error(`Edited array length (${parsedValue.length}) must match selected count (${selectedIndices.length})`); }
        for (let index = 0; index < parsedValue.length; index += 1) {
          const obj = parsedValue[index];
          if (!isNodeLike(obj)) { throw new Error(`Item ${index} is not a valid node object with a "type"`); }
          const targetIdx = selectedIndices[index];
          currentAst.children[targetIdx] = obj;
          updateRenderedNodeAt(targetIdx, obj);
        }
      } else if (selectedIndices.length > 1 && !Array.isArray(parsedValue)) {
        throw new Error('Multiple selection expects an array of nodes');
      } else if (selectedIndices.length === 1 && Array.isArray(parsedValue)) {
        throw new Error('Single selection expects a single node object');
      }
      // Renumber gutters and update collapse states
      recomputeGlobalLineNumbers();
      updateCollapseStates();
      // Re-run validation after edits to capture correct line numbers
      validateDocument();
      // Refresh selection view without clobbering editor
      suppressEditorUpdate = true; updateSelectionView(); suppressEditorUpdate = false;
      // Restore editor focus/caret if it had focus before
      if (hadFocus) {
        try {
          nodeEditor.disabled = false;
          // Defer to next frame so the value set by updateSelectionView is present
          requestAnimationFrame(() => {
            nodeEditor.focus();
            const len = nodeEditor.value.length;
            const start = Math.max(0, Math.min(prevStart, len));
            const end = Math.max(0, Math.min(prevEnd, len));
            nodeEditor.setSelectionRange(start, end);
            nodeEditor.scrollTop = prevScrollTop;
          });
        } catch (_) {}
      }
    }

    // Debounced input handler for the editor
    let editorTimer = 0;
    nodeEditor.addEventListener('input', () => {
      const text = nodeEditor.value;
      clearTimeout(editorTimer);
      editorTimer = window.setTimeout(() => {
        if (!text || selectedNodeIds.size === 0) { return; }
        try {
          const value = JSON.parse(text);
          nodeEditor.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border') || '#1f2430';
          setStatus('Applying changes...', false, true);
          applyNodeEdits(value);
          setStatus('Changes applied');
        } catch (err) {
          nodeEditor.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--danger') || '#ff6b6b';
          setStatus('Edit error: ' + (err && err.message ? err.message : String(err)), true, false);
        }
      }, 250);
    });

    // Insert two spaces on Tab within the editor
    nodeEditor.addEventListener('keydown', (event) => {
      if (event.key === 'Tab') {
        event.preventDefault();
        try {
          const start = typeof nodeEditor.selectionStart === 'number' ? nodeEditor.selectionStart : 0;
          const end = typeof nodeEditor.selectionEnd === 'number' ? nodeEditor.selectionEnd : start;
          const value = nodeEditor.value || '';
          const before = value.slice(0, start);
          const after = value.slice(end);
          const insert = '  ';
          nodeEditor.value = before + insert + after;
          const caret = start + insert.length;
          nodeEditor.setSelectionRange(caret, caret);
          // Keep scroll position stable
          nodeEditor.scrollTop = nodeEditor.scrollTop;
          // Trigger input pipeline
          nodeEditor.dispatchEvent(new InputEvent('input', { bubbles: true }));
        } catch (_) {}
      }
    });

    // Ensure the single selected block is visible with minimal scrolling.
    // If preferCenterWhenOut is true and the block is completely out of view,
    // center it; if partially visible, scroll just enough to fully reveal it.
    function ensureSelectedVisible(preferCenterWhenOut) {
      if (!renderAreaEl) { return; }
      if (selectedNodeIds.size !== 1) { return; }
      const onlyId = Array.from(selectedNodeIds)[0];
      const block = nodeContainers.get(onlyId);
      if (!block) { return; }
      if (block.classList.contains('collapsed')) { return; }
      const container = renderAreaEl;
      const containerHeight = container.clientHeight;
      const blockHeight = block.offsetHeight;
      if (blockHeight === 0) { return; }
      // If block is larger than the viewport, do not scroll
      if (blockHeight >= containerHeight) { return; }
      const margin = 8;
      // Compute block position relative to container scrollTop
      const cRect = container.getBoundingClientRect();
      const bRect = block.getBoundingClientRect();
      const blockTop = (bRect.top - cRect.top) + container.scrollTop;
      const blockBottom = blockTop + blockHeight;
      const viewTop = container.scrollTop;
      const viewBottom = viewTop + containerHeight;
      const fullyVisible = blockTop >= viewTop && blockBottom <= viewBottom;
      if (fullyVisible) { return; }
      const completelyOut = (blockBottom <= viewTop) || (blockTop >= viewBottom);
      let nextTop = viewTop;
      if (preferCenterWhenOut && completelyOut) {
        nextTop = Math.round(blockTop - (containerHeight - blockHeight) / 2);
      } else if (blockTop < viewTop) {
        // Scroll up just enough plus a small margin
        nextTop = Math.max(0, Math.round(blockTop - margin));
      } else if (blockBottom > viewBottom) {
        // Scroll down just enough plus a small margin
        nextTop = Math.round(blockBottom - containerHeight + margin);
      }
      const maxTop = container.scrollHeight - container.clientHeight;
      nextTop = Math.max(0, Math.min(nextTop, maxTop));
      if (nextTop !== viewTop) {
        container.scrollTo({ top: nextTop, behavior: 'smooth' });
      }
    }

    function toggleSelect(nodeId, event) {
      const isToggle = !!(event && (event.ctrlKey || event.metaKey));
      const isShift = !!(event && event.shiftKey);
      const isLeftClick = !!(event && (event.button === 0 || event.button == null));

      if (isShift && isLeftClick && selectionAnchorId && nodeIndex.has(selectionAnchorId) && nodeIndex.has(nodeId)) {
        const anchorIndex = nodeIndex.get(selectionAnchorId);
        const targetIndex = nodeIndex.get(nodeId);
        const start = Math.min(anchorIndex, targetIndex);
        const end = Math.max(anchorIndex, targetIndex);
        const rangeIds = nodeOrder.slice(start, end + 1);
        if (!isToggle) {
          selectedNodeIds.clear();
        }
        for (const id of rangeIds) {
          selectedNodeIds.add(id);
        }
      } else if (isToggle) {
        if (selectedNodeIds.has(nodeId)) { selectedNodeIds.delete(nodeId); } else { selectedNodeIds.add(nodeId); }
        selectionAnchorId = nodeId;
      } else {
        if (selectedNodeIds.size === 1 && selectedNodeIds.has(nodeId)) {
          selectedNodeIds.clear();
        } else {
          selectedNodeIds.clear();
          selectedNodeIds.add(nodeId);
        }
        selectionAnchorId = nodeId;
      }
      updateSelectionView();
      updateCollapseStates();
    }

    function clearSelection() {
      if (selectedNodeIds.size === 0) { return; }
      selectedNodeIds.clear();
      updateSelectionView();
      updateCollapseStates();
    }

    // Delegate block clicks to a single handler for better performance
    // Prevent text selection on Ctrl/Cmd or Shift + Left Click to keep range/multi-select crisp
    outputEl.addEventListener('mousedown', (event) => {
      const isLeft = (event && (event.button === 0));
      const hasModifier = !!(event && (event.ctrlKey || event.metaKey || event.shiftKey));
      if (isLeft && hasModifier) { event.preventDefault(); }
    });
    outputEl.addEventListener('click', (event) => {
      const target = event.target;
      if (!(target instanceof Element)) { return; }
      const block = target.closest('.block');
      if (!block || !outputEl.contains(block)) { return; }
      const nodeId = block.dataset.nodeId;
      if (!nodeId) { return; }
      toggleSelect(nodeId, event);
    });

    function renderAst(ast) {
      // Make rendering a distinct activity in the log
      setStatus('Rendering...', false, true);
      clearRender();
      if (!ast || ast.type !== 'Document' || !Array.isArray(ast.children)) {
        setStatus('Input must be a Document node with children[]', true);
        return;
      }
      currentAst = ast;
      const typesInUse = new Set();
      const frag = document.createDocumentFragment();
      let totalLines = 0;

      // Depth-first render: for each child, render its lines and map lines back to the node
      let nodeSerial = 0;
      function summarize(node, lines) {
        try {
          switch (node.type) {
            case 'Document':
              return `Document: ${node.children?.length ?? 0} blocks`;
            case 'Title':
            case 'SectionTitle':
            case 'Paragraph':
              return (lines[0] ?? '').trim() || node.type;
            case 'IndentedBlock':
              return `IndentedBlock: ${lines.length} line${lines.length !== 1 ? 's' : ''}`;
            case 'List':
              return `List: ${node.items?.length ?? 0} item${(node.items?.length ?? 0) !== 1 ? 's' : ''}`;
            case 'DefinitionList':
              return `DefinitionList: ${node.items?.length ?? 0} term${(node.items?.length ?? 0) !== 1 ? 's' : ''}`;
            case 'TableOfContents':
              return `TableOfContents: ${lines.length} entr${lines.length === 1 ? 'y' : 'ies'}`;
            case 'Figure': {
              // Try to extract a caption if present on the last non-blank line
              let caption = '';
              for (let i = lines.length - 1; i >= 0; i -= 1) {
                const t = (lines[i] || '').trim();
                if (!t) { continue; }
                const m = t.match(/^Figure\s+(\d+)\s*:\s*(.*)$/);
                if (m) {
                  caption = `Figure ${m[1]}: ${m[2]}`.trim();
                }
                break;
              }
              return caption || `Figure: ${lines.length} line${lines.length !== 1 ? 's' : ''}`;
            }
            case 'PageHeader':
              return `Header: ${(node.text ?? '').slice(0, 56)}`;
            case 'PageFooter':
              return `Footer: ${(node.text ?? '').slice(0, 56)}`;
            case 'PageBreak':
              return 'PageBreak';
            case 'BlankLine':
              return 'Blank line';
            default:
              return node.type;
          }
        } catch (_) {
          return node.type || 'Unknown';
        }
      }

      function renderNodeWithMap(node) {
        const lines = renderNode(node);
        const nodeId = makeNodeId(node, nodeSerial++);
        nodeMap.set(nodeId, node);
        nodeLines.set(nodeId, []);
        typesInUse.add(node.type || 'Unknown');

        const block = document.createElement('div');
        block.className = 'block';
        block.dataset.nodeId = nodeId;
        block.dataset.type = node.type || 'Unknown';
        nodeContainers.set(nodeId, block);
        attachBlockInteractions(block, nodeId);
        nodeOrder.push(nodeId);
        nodeIndex.set(nodeId, nodeOrder.length - 1);

        // Type label badge
        const badge = document.createElement('div');
        badge.className = 'type-badge';
        badge.textContent = node.type || 'Unknown';
        badge.setAttribute('aria-hidden', 'true');
        badge.setAttribute('role', 'presentation');
        block.appendChild(badge);

        // Sibling index (zero-based): use current node's index within its depth
        const siblingIdx = nodeIndex.get(nodeId) ?? 0;
        block.dataset.siblingIndex = String(siblingIdx);

        // No per-block toggles; collapse is global-only

        let lineNumber = 0;
        for (let index = 0; index < lines.length; index += 1) {
          const text = lines[index];
          lineNumber += 1;
          const lineEl = document.createElement('span');
          lineEl.className = 'line';
          lineEl.dataset.nodeId = nodeId;
          lineEl.dataset.type = node.type || 'Unknown';
          // Line number gutter
          const lnEl = document.createElement('span');
          lnEl.className = 'ln';
          lnEl.textContent = String(totalLines + 1); // global running count
          // Content cell
          const contentEl = document.createElement('span');
          contentEl.className = 'content';
          if ((node.type || 'Unknown') === 'PageBreak') {
            lineEl.classList.add('page-break');
            contentEl.textContent = '␌'; // SYMBOL FOR FORM FEED to visualize page breaks
          } else {
            // Use textContent with white-space: pre to preserve spacing
            contentEl.dataset.raw = text;
            if (showWhitespace) { renderWhitespaceSpans(contentEl, text); } else { contentEl.textContent = text; }
          }
        // Left index gutter (show sibling index only on the first line of the block)
        const ixEl = document.createElement('span');
        ixEl.className = 'ix';
        ixEl.textContent = (index === 0) ? String(siblingIdx) : '';

        lineEl.appendChild(ixEl);
        lineEl.appendChild(lnEl);
        lineEl.appendChild(contentEl);
          block.appendChild(lineEl);
          nodeLines.get(nodeId).push(lineEl);
          totalLines += 1;
        }
        // Summary (visible when collapsed)
        const summaryEl = document.createElement('div');
        summaryEl.className = 'summary';
        summaryEl.textContent = summarize(node, lines);
        block.appendChild(summaryEl);

        frag.appendChild(block);
      }

      for (const child of ast.children) {
        renderNodeWithMap(child);
      }

      outputEl.appendChild(frag);
      // Set fixed gutters: left index based on max sibling index, line-number based on total lines
      const digits = Math.max(2, String(totalLines).length);
      outputEl.style.setProperty('--ln-width', (digits + 2) + 'ch');
      const maxIdxDigits = Math.max(1, String(Math.max(0, nodeOrder.length - 1)).length);
      outputEl.style.setProperty('--ix-width', (maxIdxDigits + 1) + 'ch');
      buildLegend(typesInUse);
      updateCollapseStates();
      // Defer whitespace markers to idle time for smoother first paint
      scheduleWhitespaceRender();
      // Validate after initial render
      validateDocument();
      setStatus('Rendered ' + totalLines + ' lines.');
    }

    function updateCollapseStates() {
      for (const [nodeId, block] of nodeContainers.entries()) {
        const type = block.dataset.type || 'Unknown';
        const expanded = visibleTypes.has(type);
        block.classList.toggle('collapsed', !expanded);
      }
    }

    function parseAndRender() {
      try {
        setStatus('Parsing JSON...', false, true);
        const text = inputEl.value.trim();
        if (!text) { clearRender(); setStatus('No input'); return; }
        const ast = JSON.parse(text);
        renderAst(ast);
      } catch (e) {
        clearRender();
        setStatus('Parse error: ' + (e && e.message ? e.message : String(e)), true, false);
      }
    }

    // Incremental update of an already-rendered node without re-rendering everything
    function updateRenderedNodeAt(childIndex, newNode) {
      const nodeId = nodeOrder[childIndex];
      if (!nodeId) { return; }
      const block = nodeContainers.get(nodeId);
      if (!block) { return; }
      nodeMap.set(nodeId, newNode);
      block.dataset.type = newNode.type || 'Unknown';
      const badge = block.querySelector('.type-badge');
      if (badge) { badge.textContent = newNode.type || 'Unknown'; }

      // Gather the summary element if present
      const summaryEl = block.querySelector('.summary');
      // Remove existing line elements tracked for this node
      const prevLines = nodeLines.get(nodeId) || [];
      for (const el of prevLines) { if (el && el.parentNode === block) { block.removeChild(el); } }
      nodeLines.set(nodeId, []);

      const lines = renderNode(newNode);
      // Insert new line elements after the badge and before the summary
      const siblingIdx = Number(block.dataset.siblingIndex || '0');
      let insertBefore = summaryEl || null;
      let totalLines = 0; // will recompute globally later
      for (let index = 0; index < lines.length; index += 1) {
        const text = lines[index];
        const lineEl = document.createElement('span');
        lineEl.className = 'line';
        lineEl.dataset.nodeId = nodeId;
        lineEl.dataset.type = newNode.type || 'Unknown';
        const lnEl = document.createElement('span');
        lnEl.className = 'ln';
        lnEl.textContent = '';
        const contentEl = document.createElement('span');
        contentEl.className = 'content';
        if ((newNode.type || 'Unknown') === 'PageBreak') {
          lineEl.classList.add('page-break');
          contentEl.textContent = '␌';
        } else {
          contentEl.dataset.raw = text;
          if (showWhitespace) { renderWhitespaceSpans(contentEl, text); } else { contentEl.textContent = text; }
        }
        const ixEl = document.createElement('span');
        ixEl.className = 'ix';
        ixEl.textContent = (index === 0) ? String(siblingIdx) : '';
        lineEl.appendChild(ixEl);
        lineEl.appendChild(lnEl);
        lineEl.appendChild(contentEl);
        block.insertBefore(lineEl, insertBefore);
        nodeLines.get(nodeId).push(lineEl);
        totalLines += 1;
      }
      // Update summary text
      if (summaryEl) {
        try { summaryEl.textContent = (function(linesArr){
          try {
            switch (newNode.type) {
              case 'Document':
                return `Document: ${newNode.children?.length ?? 0} blocks`;
              case 'Title':
              case 'SectionTitle':
              case 'Paragraph':
                return (linesArr[0] ?? '').trim() || (newNode.type || 'Unknown');
              case 'IndentedBlock':
                return `IndentedBlock: ${linesArr.length} line${linesArr.length !== 1 ? 's' : ''}`;
              case 'List':
                return `List: ${newNode.items?.length ?? 0} item${(newNode.items?.length ?? 0) !== 1 ? 's' : ''}`;
              case 'DefinitionList':
                return `DefinitionList: ${newNode.items?.length ?? 0} term${(newNode.items?.length ?? 0) !== 1 ? 's' : ''}`;
              case 'TableOfContents':
                return `TableOfContents: ${linesArr.length} entr${linesArr.length === 1 ? 'y' : 'ies'}`;
              case 'Figure':
                return `Figure: ${linesArr.length} line${linesArr.length !== 1 ? 's' : ''}`;
              case 'PageHeader':
                return `Header: ${(newNode.text ?? '').slice(0, 56)}`;
              case 'PageFooter':
                return `Footer: ${(newNode.text ?? '').slice(0, 56)}`;
              case 'PageBreak':
                return 'PageBreak';
              case 'BlankLine':
                return 'Blank line';
              default:
                return newNode.type || 'Unknown';
            }
          } catch (_) { return newNode.type || 'Unknown'; }
        })(lines);
        } catch (_) {}
      }
      // Note: validation is run after global renumbering in applyNodeEdits
    }

    function recomputeGlobalLineNumbers() {
      // Renumber all line gutters and update gutter width based on count
      const lineEls = outputEl.querySelectorAll('.line .ln');
      let count = 0;
      for (const ln of lineEls) {
        count += 1; ln.textContent = String(count);
      }
      const digits = Math.max(2, String(count).length);
      outputEl.style.setProperty('--ln-width', (digits + 2) + 'ch');
    }

    // Validation: enforce 72-char line length, mark offending lines, and list errors
    function validateDocument() {
      // Clear previous flags
      const allLines = outputEl.querySelectorAll('.line');
      for (const line of allLines) {
        line.classList.remove('error-too-long');
      }
      validationContentEl.innerHTML = '';

      const errors = [];
      for (const line of allLines) {
        const lnEl = line.querySelector('.ln');
        const contentEl = line.querySelector('.content');
        const raw = (contentEl && (contentEl.dataset.raw != null ? contentEl.dataset.raw : contentEl.textContent)) || '';
        const length = raw.length;
        if (length > MAX_LINE_LENGTH) {
          line.classList.add('error-too-long');
          const ln = Number(lnEl && lnEl.textContent ? lnEl.textContent : '0');
          errors.push({ lineEl: line, lineNumber: ln, length, preview: raw });
        }
      }

      // Build panel UI
      if (errors.length === 0) {
        validationSummaryEl.textContent = 'Validation: no errors';
        const ok = document.createElement('div');
        ok.className = 'error-item';
        ok.innerHTML = `<span class="msg" style="color: var(--ok);">No validation errors.</span>`;
        validationContentEl.appendChild(ok);
        validationPanelEl.open = false;
        return;
      }

      validationSummaryEl.textContent = `Validation: ${errors.length} error${errors.length !== 1 ? 's' : ''}`;
      for (const err of errors) {
        const row = document.createElement('div');
        row.className = 'error-item';
        const loc = document.createElement('span');
        loc.className = 'loc';
        loc.textContent = `Line ${err.lineNumber}`;
        const msg = document.createElement('span');
        msg.className = 'msg';
        const trimmed = err.preview.replace(/\s+/g, ' ').trim();
        msg.textContent = `length ${err.length} (> ${MAX_LINE_LENGTH}) — ${trimmed.slice(0, 72)}${trimmed.length > 72 ? '…' : ''}`;
        const jump = document.createElement('button');
        jump.className = 'btn-link jump';
        jump.textContent = 'Jump';
        jump.addEventListener('click', (e) => { e.preventDefault(); scrollToLine(err.lineEl); });
        row.appendChild(loc);
        row.appendChild(msg);
        row.appendChild(jump);
        validationContentEl.appendChild(row);
      }
      validationPanelEl.open = true; // open when errors exist
    }

    function scrollToLine(lineEl) {
      if (!lineEl) { return; }
      const container = renderAreaEl;
      const cRect = container.getBoundingClientRect();
      const lRect = lineEl.getBoundingClientRect();
      const top = (lRect.top - cRect.top) + container.scrollTop - 20;
      container.scrollTo({ top: Math.max(0, top), behavior: 'smooth' });
      lineEl.classList.add('flash');
      setTimeout(() => { lineEl.classList.remove('flash'); }, 1200);
    }

    function toCorsProxy(url) {
      return 'https://no-cors.w-ixx.de/?url=' + encodeURIComponent(url);
    }

    async function fetchUrlAndParse(url) {
      if (!url) { setStatus('Enter a URL to fetch'); return; }
      try { btnFetchUrl.disabled = true; } catch (_) {}
      btnFetchUrl.classList.add('loading');
      try {
        const effectiveUrl = toCorsProxy(url);
        setStatus('Fetching: ' + effectiveUrl, false, true);
        const response = await fetch(effectiveUrl, { headers: { 'Accept': 'text/plain, */*;q=0.1' } });
        if (!response.ok) {
          throw new Error('HTTP ' + response.status + ' ' + response.statusText);
        }
        const raw = await response.text();
        setStatus('Parsing text...', false, true);
        const normalized = raw.replace(/\r?\n/g, '\n').split('\n');
        const cursor = new ArrayCursor(normalized);
        const ast = parse(cursor);
        const json = JSON.stringify(ast, null, 2);
        if (json.length <= MAX_INPUT_PREVIEW_BYTES) {
          inputEl.value = json;
        } else {
          inputEl.value = '';
        }
        renderAst(ast);
        const lineCount = document.querySelectorAll('.output .line').length;
        setStatus('Fetched and parsed. Lines: ' + lineCount + (json.length > MAX_INPUT_PREVIEW_BYTES ? ' (AST JSON omitted from input)' : ''), false, false);
      } catch (error) {
        const message = (error && error.message) ? error.message : String(error);
        setStatus('Fetch/parse error: ' + message, true, false);
      } finally {
        btnFetchUrl.classList.remove('loading');
        try { btnFetchUrl.disabled = false; } catch (_) {}
      }
    }

    btnClear.addEventListener('click', () => { inputEl.value = ''; clearRender(); setStatus('Cleared', false, false); });
    btnClearSelection.addEventListener('click', () => { clearSelection(); });
    btnFetchUrl.addEventListener('click', () => { if (!btnFetchUrl.disabled) { fetchUrlAndParse(urlInput.value.trim()); } });
    urlInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); if (!btnFetchUrl.disabled) { fetchUrlAndParse(urlInput.value.trim()); } }
    });
    // Types popover events
    btnTypes.addEventListener('click', () => {
      if (typesPopover.classList.contains('open')) { closeTypesPopover(); } else { openTypesPopover(); }
    });
    btnTypesAll.addEventListener('click', () => {
      for (const type of KNOWN_TYPES) {
        if (document.body.classList.contains('type-visible-' + type)) { continue; }
        document.body.classList.add('type-visible-' + type);
      }
      visibleTypes = new Set(KNOWN_TYPES);
      // Check all checkboxes in the list
      typesListEl.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; });
      updateCollapseStates();
      ensureSelectedVisible(true);
    });
    btnTypesNone.addEventListener('click', () => {
      for (const type of KNOWN_TYPES) {
        document.body.classList.remove('type-visible-' + type);
      }
      visibleTypes.clear();
      typesListEl.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; });
      updateCollapseStates();
      ensureSelectedVisible(true);
    });
    // Debounce filter input to avoid excessive DOM work on fast typing
    let typesFilterTimer = 0;
    typesFilterEl.addEventListener('input', () => {
      const value = typesFilterEl.value;
      clearTimeout(typesFilterTimer);
      typesFilterTimer = window.setTimeout(() => { filterTypes(value); }, 120);
    });
    btnOpenFile.addEventListener('click', () => { fileInput.click(); });
    fileInput.addEventListener('change', async () => {
      const files = fileInput.files;
      if (!files || files.length === 0) { return; }
      const file = files[0];
      await handleLocalFile(file);
      // reset to allow re-selecting the same file
      fileInput.value = '';
    });

    // Clipboard input
    btnFromClipboard.addEventListener('click', async () => {
      try {
        setStatus('Reading from clipboard...', false, true);
        let text = '';
        try {
          text = await navigator.clipboard.readText();
        } catch (err) {
          const pasted = window.prompt('Paste RFC text or AST JSON here:');
          text = pasted || '';
        }
        if (!text) { setStatus('Clipboard is empty', false, false); return; }
        const looksJson = /^[\s\uFEFF\u200B]*[\[{]/.test(text);
        if (looksJson) {
          const ast = JSON.parse(text);
          const json = JSON.stringify(ast, null, 2);
          if (json.length <= MAX_INPUT_PREVIEW_BYTES) { inputEl.value = json; } else { inputEl.value = ''; }
          renderAst(ast);
          setStatus('Loaded AST from clipboard', false, false);
          return;
        }
        const normalized = text.replace(/\r?\n/g, '\n').split('\n');
        const cursor = new ArrayCursor(normalized);
        const ast = parse(cursor);
        const json = JSON.stringify(ast, null, 2);
        if (json.length <= MAX_INPUT_PREVIEW_BYTES) { inputEl.value = json; } else { inputEl.value = ''; }
        renderAst(ast);
        setStatus('Parsed clipboard text', false, false);
      } catch (error) {
        setStatus('Clipboard error: ' + (error && error.message ? error.message : String(error)), true, false);
      }
    });

    // JSON dialog
    btnOpenJsonDialog.addEventListener('click', () => {
      // Do not prefill with current AST; start empty to load from
      inputEl.value = '';
      try { jsonDialog.showModal(); } catch (_) { jsonDialog.show(); }
    });
    btnDialogLoad.addEventListener('click', (e) => {
      e.preventDefault();
      setStatus('Loading JSON...', false, true);
      try { btnDialogLoad.disabled = true; } catch (_) {}
      btnDialogLoad.classList.add('loading');
      try {
        parseAndRender();
      } finally {
        btnDialogLoad.classList.remove('loading');
        try { btnDialogLoad.disabled = false; } catch (_) {}
        try { jsonDialog.close(); } catch (_) {}
      }
    });
    // Close dialog when clicking on backdrop
    jsonDialog.addEventListener('click', (e) => {
      const x = (e && typeof e.clientX === 'number') ? e.clientX : null;
      const y = (e && typeof e.clientY === 'number') ? e.clientY : null;
      if (x == null || y == null) { return; }
      const rect = jsonDialog.getBoundingClientRect();
      const inDialog = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
      if (!inDialog) { try { jsonDialog.close(); } catch (_) {} }
    });

    async function handleLocalFile(file) {
      try {
        setStatus('Reading file: ' + file.name, false, true);
        const text = await file.text();
        const lower = file.name.toLowerCase();
        if (lower.endsWith('.json')) {
          setStatus('Parsing JSON AST...', false, true);
          const ast = JSON.parse(text);
          const json = JSON.stringify(ast, null, 2);
          if (json.length <= MAX_INPUT_PREVIEW_BYTES) { inputEl.value = json; } else { inputEl.value = ''; }
          renderAst(ast);
          const lineCount = document.querySelectorAll('.output .line').length;
          setStatus('Loaded JSON. Lines: ' + lineCount + (json.length > MAX_INPUT_PREVIEW_BYTES ? ' (AST JSON omitted from input)' : ''), false, false);
          return;
        }
        setStatus('Parsing text via project parser...', false, true);
        const normalized = text.replace(/\r?\n/g, '\n').split('\n');
        const cursor = new ArrayCursor(normalized);
        const ast = parse(cursor);
        const json = JSON.stringify(ast, null, 2);
        if (json.length <= MAX_INPUT_PREVIEW_BYTES) { inputEl.value = json; } else { inputEl.value = ''; }
        renderAst(ast);
        const lineCount = document.querySelectorAll('.output .line').length;
        setStatus('Loaded text file. Lines: ' + lineCount + (json.length > MAX_INPUT_PREVIEW_BYTES ? ' (AST JSON omitted from input)' : ''), false, false);
      } catch (error) {
        setStatus('File load/parse error: ' + (error && error.message ? error.message : String(error)), true, false);
      }
    }
    // Splitter events (mouse + touch)
    splitterEl.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('mouseup', endDrag);
    splitterEl.addEventListener('touchstart', (e) => { startDrag(e); }, { passive: false });
    window.addEventListener('touchmove', (e) => { onDrag(e); }, { passive: false });
    window.addEventListener('touchend', endDrag);
    window.addEventListener('touchcancel', endDrag);
    btnSample.addEventListener('click', () => {
      setStatus('Loading sample...', false, true);
      // RFC-like sample focusing on the Abstract section and realistic header
      const sample = {
        type: 'Document',
        children: [
          // 0: Leading blank line
          { type: 'BlankLine' },

          // 1: Metadata
          { type: 'Metadata', lines: [
            'Interdum Egestas Typographi Factus (IETF)                  D. Ipsum, Ed.',
            'Rogatio Commentariorum: 9999                                  Lorum Corp',
            'Categoria: Specimen Tractus'
          ]},

          // 2: Blank line before title
          { type: 'BlankLine' },

          // 3: Title
          { type: 'Title', lines: [
            '                 Lorem Ipsum Dolor Sit Amet'
          ]},

          // 4: Blank line
          { type: 'BlankLine' },

          // 5: SectionTitle - Abstract
          { type: 'SectionTitle', lines: [
            'Abstract'
          ]},

          // 6: Blank line
          { type: 'BlankLine' },

          // 7: Paragraph - abstract body (acrostic: "THIS IS AN EXAMPLE TEXT")
          { type: 'Paragraph', lines: [
            '   Tenetur Habitasse Ipsum Sollicitudin Inceptos Sapien',
            '   Aenean Nascetur Eleifend Xiphoides Amet Magnis Posuere Lorem Elit',
            '   Tellus Egestas Xiphos Tristique'
          ]},

          // 8: Blank line
          { type: 'BlankLine' },

          // 9: SectionTitle - Table of Contents
          { type: 'SectionTitle', lines: [
            'Table of Contents'
          ]},

          // 10: Blank line
          { type: 'BlankLine' },

          // 11: TableOfContents - two entries (one simple, one wrapped)
            {
                "type": "TableOfContents",
                "lines": [
                    "   1. Lorem Ipsum .....................................................4",
                    "     1.1. Dolor Sit ...................................................6",
                    "   2. Amet Consectetur",
                    "     .................................................................10"
                ],
                "entries": [
                    {
                        "raw": "   1. Lorem Ipsum .....................................................4",
                        "indent": 3,
                        "title": "1. Lorem Ipsum",
                        "page": 4
                    },
                    {
                        "raw": "     1.1. Dolor Sit ...................................................6",
                        "indent": 5,
                        "title": "1.1. Dolor Sit",
                        "page": 6
                    },
                    {
                        "raw": "   2. Amet Consectetur\n     .................................................................10",
                        "indent": 3,
                        "title": "2. Amet Consectetur",
                        "page": 10
                    }
                ]
            },

          // 12: Blank line
          { type: 'BlankLine' },

          // 13: SectionTitle - Notation and Conventions
          { type: 'SectionTitle', lines: [
            'Notation and Conventions'
          ]},

          // 14: Blank line
          { type: 'BlankLine' },

          // 15: DefinitionList - terms with definitions
          { type: 'DefinitionList', items: [
            { term: 'Lorum Nomen', termIndent: 3, definitionIndent: 6, lines: [
              'Inanis descriptio de rebus fictis et vacuis.',
            ]},
            { term: 'Ipsum Signum', termIndent: 3, definitionIndent: 6, lines: [
              'Nugae sine sensu ad specimen textus implendum.',
            ]}
          ]},

          // 16: Blank line
          { type: 'BlankLine' },

          // 17: List - unordered list of grant types (with wrapped content)
          { type: 'List', items: [
            { marker: '-', markerIndent: 3, contentIndent: 5, lines: [
              'Lorum',
            ]},
            { marker: '-', markerIndent: 3, contentIndent: 5, lines: [
              'Ipsum',
            ]},
            { marker: '-', markerIndent: 3, contentIndent: 5, lines: [
              'Dolor',
            ]}
          ]},

          // 18: Blank line
          { type: 'BlankLine' },

          // 19: IndentedBlock - HTTP request example
          { type: 'IndentedBlock', indent: 4, lines: [
            'Lorem ipsum dolor sit amet, consectetur',
            'adipiscing elit, sed do eiusmod tempor',
            'incididunt ut labore et dolore magna.'
          ]},

          // 20: Blank line
          { type: 'BlankLine' },

          // 21: Figure - ASCII diagram with caption
          { type: 'Figure', lines: [
            '   +--------+                               +---------------+',
            '   |        |--(A)- Inanis Nexus ---------> |   Exemplum    |',
            '   | Lorum  |                               |     Ipsum     |',
            '   |        |<-(B)-- Vacuus Rivus --------- |               |',
            '   +--------+                               +---------------+',
            '',
            '            Figure 1: Exemplum Textus (specimen)'
          ]},

          // 22: Blank line
          { type: 'BlankLine' },

          // 23: PageFooter before a page break
          { type: 'PageFooter', text: 'Lorum                         Specimen Series                   [Page 1]' },

          // 24: PageBreak (form feed)
          { type: 'PageBreak' },

          // 25: PageHeader after page break
          { type: 'PageHeader', text: 'RFC 9999                    Lorem Ipsum Dolor Sit Amet' },

          // 26: Blank line
          { type: 'BlankLine' },

          // 27: Paragraph - continuation narrative
          { type: 'Paragraph', lines: [
            '   Nulla facit exemplaria; specimina tantum hic leguntur,',
            '   textus omnino fictus et vacuus ad usum ostensionis.'
          ]},

          // 28: Trailing blank line
          { type: 'BlankLine' }
        ]
      };
      inputEl.value = JSON.stringify(sample, null, 2);
      parseAndRender();
    });

    // Show whitespace checkbox (global)
    chkShowWhitespace.addEventListener('change', () => {
      showWhitespace = chkShowWhitespace.checked;
      applyWhitespaceVisibility();
    });

    // Init: compute 72ch minimum and set default split
    (function initLayout() {
      function computeMinLeftFromCh() {
        const probe = document.createElement('div');
        probe.style.position = 'absolute';
        probe.style.visibility = 'hidden';
        probe.style.width = '72ch';
        probe.style.whiteSpace = 'pre';
        // Match body/output font preference
        probe.style.fontFamily = 'Consolas, monospace';
        probe.style.fontSize = getComputedStyle(document.documentElement).getPropertyValue('--code-size') || '13px';
        document.body.appendChild(probe);
        const width = Math.ceil(probe.getBoundingClientRect().width);
        probe.remove();
        return Math.max(400, width + 32); // account for padding; clamp to reasonable minimum
      }
      minLeftPx = computeMinLeftFromCh();
      const rect = layoutEl.getBoundingClientRect();
      const splitterWidth = 6; // CSS width
      const maxLeft = rect.width - splitterWidth - minRightPx;
      const desiredDefault = 790; // default left column width in pixels
      const defaultLeft = Math.max(minLeftPx, Math.min(desiredDefault, maxLeft));
      setLeftWidth(defaultLeft);
      window.addEventListener('resize', () => {
        minLeftPx = computeMinLeftFromCh();
        const rect2 = layoutEl.getBoundingClientRect();
        const splitterWidth = 6; // CSS width
        const maxLeft = rect2.width - splitterWidth - minRightPx;
        const left = currentLeft == null ? defaultLeft : currentLeft;
        setLeftWidth(Math.max(minLeftPx, Math.min(left, maxLeft)));
      });
    })();

    // Auto-render sample on load to show UI
    btnSample.click();
  </script>
</body>
</html>
