<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>RFC Viewer</title>
        <style>
            :root {
                --bg: #0b0c0f;
                --panel: #12141a;
                --muted: #a6adbb;
                --text: #e7e9ee;
                --accent: #7aa2f7;
                --danger: #ff6b6b;
                --ok: #22c55e;
                --warn: #f59e0b;
                --border: #1f2430;

                /* Type colors (muted, distinct, cohesive) */
                --Paragraph: rgba(88, 130, 193, 0.22); /* muted blue */
                --BlankLine: rgba(255, 255, 255, 0.03); /* near background */
                --IndentedBlock: rgba(149, 110, 186, 0.22); /* muted purple */
                --Metadata: rgba(210, 160, 96, 0.22); /* muted orange */
                --Title: rgba(84, 170, 120, 0.22); /* muted green */
                --SectionTitle: rgba(190, 110, 110, 0.22); /* muted red */
                /* PageBreak: near-background, distinct from BlankLine */
                --PageBreak: rgba(114, 124, 202, 0.08);
                --PageFooter: rgba(114, 124, 202, 0.08);
                --PageHeader: rgba(114, 124, 202, 0.08);
                --List: rgba(88, 176, 168, 0.22); /* muted teal */
                --DefinitionList: rgba(142, 180, 102, 0.22); /* olive */
                --TableOfContents: rgba(176, 146, 100, 0.22); /* muted amber */
                --Figure: rgba(206, 120, 160, 0.22); /* muted rose */
                --Table: rgba(153, 184, 120, 0.22); /* muted moss */
                --PaketDiagram: rgba(153, 184, 120, 0.22); /* muted moss */
                --HttpResponse: rgba(122, 162, 247, 0.18); /* soft blue tint */
                --HttpRequest: rgba(122, 247, 162, 0.18); /* soft green tint */
                --Abnf: rgba(247, 162, 122, 0.18); /* soft orange tint */
                --Document: rgba(255, 255, 255, 0.06); /* very subtle */

                /* Sizing */
                --code-size: 14px;
                /* Column guide at 73 characters (after 72), monospace ch units */
                --col-guide: 73ch;
                --col-guide-color: rgba(166, 173, 187, 0.25); /* muted */
            }

            html, body {
                height: 100%;
            }

            body {
                margin: 0;
                font-family: Consolas, monospace;
                color: var(--text);
                background: var(--bg);
            }

            /* drag guide for splitter (no layout during drag) */
            .splitter-guide {
                position: absolute;
                top: 0;
                bottom: 0;
                width: 6px;
                background: #1d2a45;
                border-left: 1px solid var(--border);
                border-right: 1px solid var(--border);
                pointer-events: none;
                z-index: 10;
            }

            .app {
                display: grid;
                grid-template-rows: auto 1fr;
                height: 100%;
            }

            header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 12px;
                border-bottom: 1px solid var(--border);
                background: var(--panel);
            }

            .header-lg-gap {
                gap: 16px;
            }

            header h1 {
                font-size: 14px;
                margin: 0;
                font-weight: 600;
                letter-spacing: 0.3px;
            }

            header .left-tools {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-left: 12px;
            }

            header .toolbar {
                margin-left: auto;
                display: flex;
                align-items: center;
                gap: 8px;
                flex-wrap: wrap;
            }

            header .toolbar .tool-group {
                display: flex;
                align-items: center;
                gap: 6px;
                flex-wrap: nowrap;
            }

            header .toolbar .tool-group button {
                flex: 0 0 auto;
            }

            header .toolbar .tool-group + .tool-group {
                border-left: 1px solid var(--border);
                padding-left: 10px;
            }

            button, .btn {
                background: #1b2331;
                color: var(--text);
                border: 1px solid var(--border);
                padding: 6px 10px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 12px;
                white-space: nowrap;
            }

            button:disabled {
                opacity: 0.6;
                cursor: default;
            }

            @keyframes spin {
                from {
                    transform: rotate(0deg);
                }
                to {
                    transform: rotate(360deg);
                }
            }

            /* Loading indicator in buttons */
            button.loading::before, .btn.loading::before {
                content: '';
                display: inline-block;
                width: 10px;
                height: 10px;
                margin-right: 6px;
                border: 2px solid #2b3445;
                border-top-color: var(--accent);
                border-radius: 50%;
                animation: spin 1s linear infinite;
                vertical-align: -1px;
            }

            /* Ensure all UI controls render in monospace */
            button, .btn, input, select, textarea, label {
                font-family: inherit;
                font-variant-ligatures: none;
            }

            button:hover {
                border-color: #2b3445;
            }

            .hidden {
                display: none !important;
            }

            .layout {
                display: grid;
                position: relative;
                grid-template-columns: var(--left-width, 60%) 6px 1fr; /* left | splitter | right */
                gap: 0;
                height: 100%;
            }

            .splitter {
                background: #101521;
                border-left: 1px solid var(--border);
                border-right: 1px solid var(--border);
                cursor: col-resize;
            }

            .splitter:hover {
                background: #162033;
            }

            body.dragging .splitter {
                background: #1d2a45;
            }

            body.dragging {
                user-select: none;
                cursor: col-resize;
            }

            .panel {
                display: flex;
                flex-direction: column;
                border-right: 1px solid var(--border);
            }

            .panel:last-child {
                border-right: none;
            }

            .panel header {
                border: none;
                border-bottom: 1px solid var(--border);
            }

            .panel .body {
                flex: 1;
                min-height: 0;
            }

            .input-wrap {
                display: grid;
                grid-template-rows: auto 1fr;
                height: 100%;
            }

            .input-controls {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 12px;
            }

            .toolbar-grow {
                flex: 1 1 auto;
                min-width: 360px;
            }

            .header-actions {
                margin-left: auto;
                display: flex;
                gap: 8px;
            }

            .url-input {
                flex: 2 1 640px;
                min-width: 360px;
                max-width: 70vw;
                padding: 6px 8px;
                border-radius: 6px;
                border: 1px solid var(--border);
                background: #0c111b;
                color: var(--text);
            }

            textarea {
                width: 100%;
                height: 100%;
                box-sizing: border-box;
                resize: none;
                outline: none;
                border: 1px solid var(--border);
                background: #0c111b;
                color: var(--text);
                padding: 12px;
                font-size: var(--code-size);
                line-height: 1.6;
                border-radius: 8px;
                tab-size: 4;
            }

            textarea:focus {
                border-color: #2b3445;
                box-shadow: inset 0 0 0 1px #2b3445, 0 0 0 2px rgba(122, 162, 247, 0.15);
            }

            .render-wrap {
                display: grid;
                grid-template-rows: auto 1fr;
                height: 100%;
            }

            .legend {
                display: flex;
                flex-wrap: wrap;
                gap: 6px 10px;
                padding: 8px 12px;
                border-bottom: 1px solid var(--border);
                background: #0f1320;
            }

            .legend .item {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-size: 12px;
                color: var(--muted);
                cursor: pointer;
                user-select: none;
                font-family: inherit;
            }

            .legend .swatch {
                width: 12px;
                height: 12px;
                border-radius: 3px;
                outline: 1px solid var(--border);
            }

            .legend .item input {
                margin: 0;
            }

            .muted {
                color: var(--muted);
            }

            /* Types popover for scalable type toggles */
            .types-popover {
                position: absolute;
                z-index: 20;
                background: var(--panel);
                color: var(--text);
                border: 1px solid var(--border);
                border-radius: 8px;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
                min-width: 260px;
                max-width: 520px;
                max-height: 60vh;
                overflow: hidden;
                display: none;
            }

            .types-popover.open {
                display: block;
            }

            .types-popover header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                background: #0f1320;
                border-bottom: 1px solid var(--border);
            }

            .types-popover header .title {
                font-size: 12px;
                font-weight: 600;
            }

            .types-popover .controls {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                border-bottom: 1px solid var(--border);
            }

            .types-popover .controls .spacer {
                flex: 1 1 auto;
            }

            .types-popover .filter {
                width: 100%;
                box-sizing: border-box;
                padding: 6px 8px;
                border-radius: 6px;
                border: 1px solid var(--border);
                background: #0c111b;
                color: var(--text);
                font-family: inherit;
                font-size: 12px;
            }

            .types-popover .list {
                padding: 8px 10px;
                overflow: auto;
                max-height: 44vh;
                display: grid;
                grid-template-columns: 1fr;
                gap: 6px;
            }

            .types-popover .list .item {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .types-popover .list .item .swatch {
                width: 12px;
                height: 12px;
                border-radius: 3px;
                outline: 1px solid var(--border);
            }

            .types-popover .footer {
                display: flex;
                align-items: center;
                justify-content: flex-end;
                gap: 8px;
                padding: 8px 10px;
                border-top: 1px solid var(--border);
            }

            .layout, .panel {
                min-height: 0;
            }

            .render-area {
                position: relative;
                height: 100%;
                overflow-y: scroll;
                overflow-x: auto;
                contain: paint;
            }

            .output {
                position: relative;
                margin: 0;
                padding: 8px 12px;
                background: transparent;
                border: none;
                color: var(--text);
                white-space: pre;
                line-height: 1.6;
                font-size: var(--code-size);
                font-family: Consolas, monospace;
                font-variant-ligatures: none;
            }

            /* Line with fixed-width left index gutter, line-number gutter, and content */
            .output .line {
                display: grid;
                grid-template-columns: var(--ix-width, 3ch) var(--ln-width, 4ch) 1fr;
                align-items: baseline;
                position: relative;
            }

            .output .line .ix {
                color: var(--muted);
                opacity: 0.7;
                text-align: right;
                padding-right: 6px;
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
            }

            .output .line .ln {
                color: var(--muted);
                opacity: 0.7;
                text-align: right;
                padding-right: 8px;
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
            }

            .output .line .content {
                display: inline-block;
                padding: 0 6px;
                position: relative;
            }

            .output .line::selection {
                background: rgba(122, 162, 247, 0.35);
            }

            /* Visible whitespace markers: overlay via ::before so actual whitespace remains copyable */
            .output .line .ws {
                position: relative;
                display: inline-block;
                color: var(--muted);
                opacity: 0.7;
            }

            .output .line .ws::before {
                position: absolute;
                left: 0;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                text-align: center;
                color: var(--muted);
                opacity: 0.7;
                pointer-events: none;
                font-size: 8px;
                line-height: 1;
            }

            .output .line .ws.ws-space::before {
                content: '·';
                font-size: 12px;
            }

            .output .line .ws.ws-tab::before {
                content: '⇥';
            }

            /* Ensure blank lines occupy vertical space without inserting spaces */
            .output .line:empty::before {
                content: "\200B";
            }

            /* Column guide at 72 characters (from content start). Use absolute overlay so it persists with type tints. */
            .output .line::after {
                content: '';
                position: absolute;
                top: 0;
                bottom: 0;
                left: calc(var(--ix-width, 3ch) + var(--ln-width, 4ch) + var(--col-guide));
                width: 0;
                border-left: 1px solid var(--col-guide-color);
                pointer-events: none;
            }

            /* Validation highlighting for errors (e.g., over-72-char lines) */
            .output .line.error-too-long {
                /* stronger overall tint */
                background-color: rgba(255, 59, 59, 0.18);
            }

            /* Bold left-edge danger stripe for instant recognition */
            .output .line.error-too-long::before {
                content: '';
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                width: 6px;
                background: var(--danger);
                box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.2) inset;
                pointer-events: none;
            }

            /* Strong overlay beyond the 72-char column with warning stripes */
            .output .line.error-too-long .content::after {
                content: '';
                position: absolute;
                top: 0;
                bottom: 0;
                left: var(--col-guide);
                right: 0;
                background: repeating-linear-gradient(45deg,
                rgba(255, 107, 107, 0.45), rgba(255, 107, 107, 0.45) 8px,
                rgba(255, 107, 107, 0.20) 8px, rgba(255, 107, 107, 0.20) 16px
                );
                pointer-events: none;
            }

            /* Make the column guide bold and red on error lines */
            .output .line.error-too-long::after {
                border-left-color: var(--danger);
                border-left-width: 2px;
            }

            .output .line.error-too-long .ln,
            .output .line.error-too-long .ix {
                color: var(--danger);
                font-weight: 600;
            }

            /* Add an inline alert badge in the index gutter */
            .output .line.error-too-long .ix::after {
                content: '⛔';
                margin-left: 4px;
                font-size: 11px;
                color: var(--danger);
                opacity: 0.95;
            }

            .output .line.flash {
                outline: 3px solid var(--accent);
                outline-offset: -1px;
                background-color: rgba(122, 162, 247, 0.10);
            }

            /* Visualize page breaks explicitly */
            .output .line.page-break {
                color: var(--muted);
            }

            /* Node block container to group multi-line nodes for unified outlines */
            .output .block {
                display: block;
                position: relative;
                /* Always show a subtle border around rendered items */
                border: 1px solid var(--border);
                border-radius: 0;
                margin: 2px 0;
                /* Hint to the browser that outline may change on hover/selection */
                will-change: outline;
            }

            /* Make labels non-selectable so they don't end up in clipboard */
            .output .block .type-badge {
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                pointer-events: none;
            }

            /* Hover uses pure CSS to avoid JS-induced lag */
            .output .block:hover {
                outline: 1px solid #2d3b59;
                outline-offset: -1px;
            }

            .output .block.selected {
                outline: 2px solid var(--accent);
                outline-offset: -1px;
            }

            /* Small type label at top-right of each block */
            .output .block .type-badge {
                position: absolute;
                top: 0;
                right: 0;
                font-size: 10px;
                line-height: 1;
                color: var(--text);
                background: var(--border);
                border: 1px solid var(--border);
                border-radius: 0;
                padding: 2px 4px;
                pointer-events: none; /* do not block clicks on the block */
                opacity: 0.9;
            }

            /* Badges share the same background as borders (override any per-type tints) */
            .output .block[data-type] .type-badge {
                background: var(--border);
            }

            /* Highlight overlays via background on lines for the node’s type (gated by visibility classes) */
            .type-visible-Paragraph .output .line[data-type="Paragraph"] {
                background: var(--Paragraph);
            }

            .type-visible-BlankLine .output .line[data-type="BlankLine"] {
                background: var(--BlankLine);
            }

            .type-visible-IndentedBlock .output .line[data-type="IndentedBlock"] {
                background: var(--IndentedBlock);
            }

            .type-visible-Metadata .output .line[data-type="Metadata"] {
                background: var(--Metadata);
            }

            .type-visible-Title .output .line[data-type="Title"] {
                background: var(--Title);
            }

            .type-visible-SectionTitle .output .line[data-type="SectionTitle"] {
                background: var(--SectionTitle);
            }

            .type-visible-PageBreak .output .line[data-type="PageBreak"] {
                background: var(--PageBreak);
            }

            .type-visible-PageFooter .output .line[data-type="PageFooter"] {
                background: var(--PageFooter);
            }

            .type-visible-PageHeader .output .line[data-type="PageHeader"] {
                background: var(--PageHeader);
            }

            .type-visible-List .output .line[data-type="List"] {
                background: var(--List);
            }

            .type-visible-DefinitionList .output .line[data-type="DefinitionList"] {
                background: var(--DefinitionList);
            }

            .type-visible-TableOfContents .output .line[data-type="TableOfContents"] {
                background: var(--TableOfContents);
            }

            .type-visible-Figure .output .line[data-type="Figure"] {
                background: var(--Figure);
            }

            .type-visible-Table .output .line[data-type="Table"] {
                background: var(--Table);
            }

            .type-visible-PaketDiagram .output .line[data-type="PaketDiagram"] {
                background: var(--PaketDiagram);
            }

            .type-visible-HttpResponse .output .line[data-type="HttpResponse"] {
                background: var(--HttpResponse);
            }

            .type-visible-HttpRequest .output .line[data-type="HttpRequest"] {
                background: var(--HttpRequest);
            }

            .type-visible-Abnf .output .line[data-type="Abnf"] {
                background: var(--Abnf);
            }

            .type-visible-Document .output .line[data-type="Document"] {
                background: var(--Document);
            }

            /* Hover and selection are now applied to .block containers */

            .details {
                display: grid;
                grid-template-rows: auto 1fr;
                height: 100%;
            }

            .details .header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 12px;
                border-bottom: 1px solid var(--border);
                background: #0f1320;
            }

            .details .header .title {
                font-size: 12px;
                font-weight: 600;
                margin: 0;
                letter-spacing: 0.2px;
            }

            .details .content {
                height: 100%;
                overflow: auto;
            }

            .details pre {
                margin: 0;
                padding: 12px;
                white-space: pre;
                font-size: 12px;
                line-height: 1.45;
            }

            .status {
                font-size: 12px;
                color: var(--muted);
                padding: 8px 12px;
                border-top: 1px solid var(--border);
            }

            .status.loading::before {
                content: '';
                display: inline-block;
                width: 10px;
                height: 10px;
                margin-right: 8px;
                border: 2px solid #2b3445;
                border-top-color: var(--accent);
                border-radius: 50%;
                animation: spin 1s linear infinite;
                vertical-align: -1px;
            }

            .error {
                color: var(--danger);
            }

            /* Modal backdrop for JSON dialog */
            dialog::backdrop {
                background: rgba(5, 8, 15, 0.6);
            }

            /* Activity log styles */
            .log {
                border-top: 1px solid var(--border);
            }

            .log summary {
                list-style: none;
                cursor: pointer;
                padding: 6px 12px;
                color: var(--muted);
                background: #0f1320;
                user-select: none;
            }

            .log summary::marker {
                display: none;
            }

            .log pre {
                margin: 0;
                padding: 8px 12px;
                font-size: 12px;
                line-height: 1.45;
                color: var(--muted);
                max-height: 200px;
                overflow: auto;
                white-space: pre;
            }

            /* Validation panel styles */
            .validation {
                border-top: 1px solid var(--border);
            }

            .validation summary {
                list-style: none;
                cursor: pointer;
                padding: 6px 12px;
                color: var(--muted);
                background: #0f1320;
                user-select: none;
                display: flex;
                gap: 8px;
                align-items: baseline;
            }

            .validation summary::marker {
                display: none;
            }

            .validation .content {
                padding: 6px 12px;
                display: grid;
                gap: 6px;
                max-height: 240px;
                overflow: auto;
            }

            .validation .error-item {
                display: flex;
                gap: 8px;
                align-items: baseline;
                font-size: 12px;
                color: var(--text);
            }

            .validation .error-item .loc {
                color: var(--danger);
                min-width: 10ch;
            }

            .validation .error-item .msg {
                color: var(--muted);
            }

            .validation .error-item .jump {
                margin-left: auto;
            }

            .validation .btn-link {
                background: transparent;
                color: var(--accent);
                border: none;
                padding: 0;
                cursor: pointer;
                font-size: 12px;
                text-decoration: underline;
            }

            /* Dialogs */
            .dialog {
                border: 1px solid var(--border);
                background: var(--panel);
                color: var(--text);
                padding: 0;
                border-radius: 8px;
                width: min(960px, 92vw);
            }

            .dialog form {
                display: flex;
                flex-direction: column;
                max-height: 80vh;
            }

            .dialog-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 12px;
                border-bottom: 1px solid var(--border);
                background: #0f1320;
            }

            .dialog-content {
                padding: 8px 12px;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .dialog-footer {
                display: flex;
                gap: 8px;
                padding: 8px 12px;
                border-top: 1px solid var(--border);
                background: #0f1320;
            }

            .menu-btn {
                width: 100%;
                text-align: left;
            }

            .dialog-header strong {
                font-size: 12px;
            }

            .types-popover .dialog-content.narrow {
                padding: 8px 10px;
            }

            .types-popover .list.max50 {
                max-height: 50vh;
                overflow: auto;
            }

            /* App root rows */
            .app-root {
                grid-template-rows: auto auto 1fr auto;
                height: 100vh;
            }
        </style>
    </head>
    <body>
        <div class="app app-root">
            <header class="header-lg-gap">
                <h1>RFC Viewer</h1>
                <div class="toolbar">
                    <!-- Source: URL input & single URL loader -->
                    <div class="tool-group toolbar-grow">
                        <input class="url-input" id="urlInput" placeholder="https://www.rfc-editor.org/rfc/rfc6749.txt"
                               type="url"
                               value="https://www.rfc-editor.org/rfc/rfc6749.txt"/>
                        <button id="btnFetchUrl" title="Fetch URL and auto-detect JSON/TXT">From URL</button>
                    </div>
                    <!-- Hidden file inputs for dropdown actions -->
                    <input accept=".json,application/json" class="hidden" id="fileInputJson" type="file"/>
                    <input accept=".txt,text/plain" class="hidden" id="fileInputTxt" type="file"/>
                    <!-- Consolidated loader dropdown -->
                    <div class="tool-group">
                        <button id="btnLoadFrom" title="Load from...">Load From ▾</button>
                    </div>
                    <!-- Utilities -->
                    <div class="tool-group">
                        <button id="btnSample" title="Insert a small sample AST">Load Sample</button>
                        <button id="btnClear">Clear</button>
                    </div>
                </div>
            </header>

            <div class="legend hidden" id="legend"></div>

            <div class="layout" id="mainLayout">
                <div class="panel render-panel">
                    <div class="details">
                        <div class="header">
                            <span class="title">Rendered Output</span>
                            <div class="header-actions">
                                <button id="btnTypesLocal" title="Show/hide node types">Filter</button>
                                <button id="btnCopyOutputTxt" title="Copy full rendered text output">Copy TXT</button>
                                <button id="btnCopyOutputJson" title="Copy full AST JSON">Copy JSON</button>
                            </div>
                        </div>
                        <div class="content">
                            <div class="render-area" id="renderArea">
                                <pre class="output" id="output"></pre>
                            </div>
                        </div>
                    </div>
                </div>
                <div aria-label="Resize panels" aria-orientation="vertical" class="splitter" id="splitter"
                     role="separator" tabindex="0"></div>
                <div class="panel">
                    <div class="details">
                        <div class="header">
                            <span class="title">Selected Node(s)</span>
                            <span class="muted" id="selInfo"></span>
                            <div class="header-actions">
                                <button disabled id="btnCopySelectionTxt"
                                        title="Copy rendered text for selected node(s)">Copy TXT
                                </button>
                                <button disabled id="btnCopySelectionJson" title="Copy JSON for selected node(s)">Copy
                                    JSON
                                </button>
                                <button id="btnClearSelection">Clear Selection</button>
                            </div>
                        </div>
                        <div class="content">
                            <textarea disabled id="nodeEditor" placeholder="(Select a node to edit JSON)"
                                      spellcheck="false"></textarea>
                        </div>
                    </div>
                </div>
            </div>

            <div class="status" id="status"></div>
            <details class="validation" id="validationPanel">
                <summary><span id="validationSummary">Validation</span></summary>
                <div class="content" id="validationContent"></div>
            </details>
            <details class="log" id="logPanel">
                <summary>Activity Log</summary>
                <pre id="statusLog"></pre>
            </details>
        </div>

        <!-- Types Popover (scalable alternative to checkbox row) -->
        <div aria-label="Node Types" aria-modal="false" class="types-popover" id="typesPopover" role="dialog"
             tabindex="-1">
            <header><span class="title">Node Types</span></header>
            <div class="controls">
                <button class="btn" id="btnTypesAll">All</button>
                <button class="btn" id="btnTypesNone">None</button>
                <span class="spacer"></span>
                <label class="item">
                    <input id="chkShowWhitespace" type="checkbox"/>
                    <span>Show whitespace</span>
                </label>
            </div>
            <div class="dialog-content narrow">
                <input class="filter" id="typesFilter" placeholder="Filter types"/>
            </div>
            <div class="list" id="typesList"></div>
        </div>

        <!-- Load From Popover -->
        <div aria-label="Load From" aria-modal="false" class="types-popover" id="loadPopover" role="menu" tabindex="-1">
            <header><span class="title">Load From</span></header>
            <div class="controls hidden"></div>
            <!-- Intentionally no search/filter input -->
            <div class="list max50" id="loadList">
                <label class="item">
                    <button class="btn menu-btn" id="menuJsonDialog">JSON</button>
                </label>
                <label class="item">
                    <button class="btn menu-btn" id="menuTxtDialog">TXT</button>
                </label>
                <label class="item">
                    <button class="btn menu-btn" id="menuJsonClipboard">JSON-Clipboard</button>
                </label>
                <label class="item">
                    <button class="btn menu-btn" id="menuTxtClipboard">TXT-Clipboard</button>
                </label>
                <label class="item">
                    <button class="btn menu-btn" id="menuJsonFile">JSON File</button>
                </label>
                <label class="item">
                    <button class="btn menu-btn" id="menuTxtFile">TXT File</button>
                </label>
            </div>
        </div>

        <!-- JSON Input Dialog -->
        <dialog class="dialog" id="jsonDialog">
            <form method="dialog">
                <header class="dialog-header">
                    <strong>Paste JSON AST</strong>
                    <small class="muted">Paste a Document node</small>
                </header>
                <div class="dialog-content">
                    <label class="muted" for="input">AST JSON</label>
                    <textarea id="input" placeholder='{"type":"Document","children":[...]}' rows="12"></textarea>
                </div>
                <footer class="dialog-footer">
                    <button value="cancel">Cancel</button>
                    <button id="btnDialogLoad" value="default">Load</button>
                </footer>
            </form>
        </dialog>

        <!-- TXT Input Dialog -->
        <dialog class="dialog" id="txtDialog">
            <form method="dialog">
                <header class="dialog-header">
                    <strong>Paste RFC Text</strong>
                    <small class="muted">Paste plain RFC-like text</small>
                </header>
                <div class="dialog-content">
                    <label class="muted" for="inputTxt">RFC TXT</label>
                    <textarea id="inputTxt" placeholder="Paste RFC text here" rows="12"></textarea>
                </div>
                <footer class="dialog-footer">
                    <button value="cancel">Cancel</button>
                    <button id="btnDialogLoadTxt" value="default">Load</button>
                </footer>
            </form>
        </dialog>

        <script type="module">
            import {renderNode} from './dist/Tree/Render/RenderNode.js';
            import {renderToString} from './dist/Tree/Render/RenderToString.js';
            import {parse} from './dist/Tree/Parser.js';
            import {ArrayCursor} from './dist/Utils/ArrayCursor.js';

            // Config
            const AUTO_LOAD_SAMPLE = true; // render sample on load

            // Tiny helpers (KISS) — no hidden globals
            const qs = (sel, root = document) => root.querySelector(sel);
            const qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));
            const on = (el, type, handler, opts) => el.addEventListener(type, handler, opts);
            const off = (el, type, handler, opts) => el.removeEventListener(type, handler, opts);
            const debounce = (fn, wait = 200) => {
                let timer = 0;
                return (...args) => {
                    clearTimeout(timer);
                    timer = window.setTimeout(() => fn(...args), wait);
                };
            };
            const clamp = (n, min, max) => Math.max(min, Math.min(n, max));

            // UI logic
            const inputEl = document.getElementById('input');
            const outputEl = document.getElementById('output');
            const statusEl = document.getElementById('status');
            const logPanelEl = document.getElementById('logPanel');
            const statusLogEl = document.getElementById('statusLog');
            const validationPanelEl = document.getElementById('validationPanel');
            const validationSummaryEl = document.getElementById('validationSummary');
            const validationContentEl = document.getElementById('validationContent');
            const typesPopover = document.getElementById('typesPopover');
            const typesListEl = document.getElementById('typesList');
            const btnTypesAll = document.getElementById('btnTypesAll');
            const btnTypesNone = document.getElementById('btnTypesNone');
            const typesFilterEl = document.getElementById('typesFilter');
            const chkShowWhitespace = document.getElementById('chkShowWhitespace');
            const nodeEditor = document.getElementById('nodeEditor');
            const selInfoEl = document.getElementById('selInfo');

            const btnSample = document.getElementById('btnSample');
            const btnClear = document.getElementById('btnClear');
            const btnClearSelection = document.getElementById('btnClearSelection');
            const btnCopySelectionTxt = document.getElementById('btnCopySelectionTxt');
            const btnCopySelectionJson = document.getElementById('btnCopySelectionJson');
            const btnCopyOutputTxt = document.getElementById('btnCopyOutputTxt');
            const btnCopyOutputJson = document.getElementById('btnCopyOutputJson');
            const btnTypesLocal = document.getElementById('btnTypesLocal');
            const urlInput = document.getElementById('urlInput');
            const btnFetchUrl = document.getElementById('btnFetchUrl');
            const btnLoadFrom = document.getElementById('btnLoadFrom');
            const fileInputJson = document.getElementById('fileInputJson');
            const fileInputTxt = document.getElementById('fileInputTxt');
            const layoutEl = document.getElementById('mainLayout');
            const renderAreaEl = document.getElementById('renderArea');
            const splitterEl = document.getElementById('splitter');
            const btnOpenJsonDialog = document.getElementById('btnOpenJsonDialog');
            const jsonDialog = document.getElementById('jsonDialog');
            const txtDialog = document.getElementById('txtDialog');
            const btnDialogLoad = document.getElementById('btnDialogLoad');
            const btnDialogLoadTxt = document.getElementById('btnDialogLoadTxt');
            const inputTxtEl = document.getElementById('inputTxt');
            const loadPopover = document.getElementById('loadPopover');
            const menuJsonDialog = document.getElementById('menuJsonDialog');
            const menuTxtDialog = document.getElementById('menuTxtDialog');
            const menuJsonClipboard = document.getElementById('menuJsonClipboard');
            const menuTxtClipboard = document.getElementById('menuTxtClipboard');
            const menuJsonFile = document.getElementById('menuJsonFile');
            const menuTxtFile = document.getElementById('menuTxtFile');

            let currentAst = null;
            let nodeMap = new Map(); // nodeId -> node
            let nodeLines = new Map(); // nodeId -> array of line elements
            let nodeContainers = new Map(); // nodeId -> block container element
            let nodeOrder = []; // nodeIds in render order
            let nodeIndex = new Map(); // nodeId -> index in nodeOrder
            let visibleTypes = new Set(); // which types are toggled visible
            let selectedNodeIds = new Set();
            let selectionAnchorId = null; // last anchor for Shift+Click range
            let showWhitespace = true; // whether to visualize spaces and tabs
            let isDragging = false;
            let containerRect = null;
            let minLeftPx = 740; // will be recomputed based on 72ch
            let minRightPx = 240; // slightly smaller JSON panel for compactness
            let currentLeft = null;
            let suppressEditorUpdate = false; // do not overwrite editor while applying edits

            const KNOWN_TYPES = [
                'Document', 'Title', 'SectionTitle', 'Metadata', 'Paragraph', 'IndentedBlock', 'List', 'DefinitionList', 'TableOfContents', 'Figure', 'Table', 'PaketDiagram', 'HttpResponse', 'HttpRequest', 'Abnf', 'BlankLine', 'PageHeader', 'PageFooter', 'PageBreak'
            ];
            const MAX_INPUT_PREVIEW_BYTES = 1_000_000;
            const MAX_LINE_LENGTH = 72; // validator threshold

            // Lightweight activity log for status changes and durations
            const statusLog = [];
            let activeOperation = null; // { text, startedAtMs, startedIso }
            const MAX_LOG_LINES = 400;

            function pad2(n) {
                return n.toString().padStart(2, '0');
            }

            function formatClock(date) {
                const hh = pad2(date.getHours());
                const mm = pad2(date.getMinutes());
                const ss = pad2(date.getSeconds());
                const ms = date.getMilliseconds().toString().padStart(3, '0');
                return `${hh}:${mm}:${ss}.${ms}`;
            }

            function appendLogLine(line) {
                // Maintain an in-memory list and update the UI efficiently
                statusLog.push(line);
                if (statusLog.length > MAX_LOG_LINES) {
                    statusLog.shift();
                }
                statusLogEl.textContent = statusLog.join('\n');
                // Auto-scroll to bottom when open
                if (logPanelEl.open) {
                    statusLogEl.scrollTop = statusLogEl.scrollHeight;
                }
            }

            // Initialize header controls as disabled until content renders
            try {
                if (btnTypesLocal) {
                    btnTypesLocal.disabled = true;
                }
                if (btnCopyOutputTxt) {
                    btnCopyOutputTxt.disabled = true;
                }
                if (btnCopyOutputJson) {
                    btnCopyOutputJson.disabled = true;
                }
                if (btnCopySelectionTxt) {
                    btnCopySelectionTxt.disabled = true;
                }
                if (btnCopySelectionJson) {
                    btnCopySelectionJson.disabled = true;
                }
                if (btnClearSelection) {
                    btnClearSelection.disabled = true;
                }
            } catch (_) {
            }

            function recordStatus(text, isError, isLoading) {
                const nowDate = new Date();
                const nowClock = formatClock(nowDate);
                const nowMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                const label = (text || '').trim();

                // Start of an operation
                if (isLoading) {
                    if (activeOperation != null) {
                        // Implicitly complete the previous operation before starting the next stage
                        const elapsedMs = Math.max(0, Math.round(nowMs - activeOperation.startedAtMs));
                        appendLogLine(`[${nowClock}] ✔ Done: "${activeOperation.text}" in ${elapsedMs} ms`);
                    }
                    activeOperation = {
                        text: label || '(loading)',
                        startedAtMs: nowMs,
                        startedIso: nowDate.toISOString()
                    };
                    appendLogLine(`[${nowClock}] ▶ Start: "${activeOperation.text}"`);
                    return;
                }

                // End of an operation (success or error), if any
                if (activeOperation != null) {
                    const elapsedMs = Math.max(0, Math.round(nowMs - activeOperation.startedAtMs));
                    const outcome = isError ? '✖ Error' : '✔ Done';
                    const endLabel = label && label !== activeOperation.text ? ` → ${label}` : '';
                    appendLogLine(`[${nowClock}] ${outcome}: "${activeOperation.text}"${endLabel} in ${elapsedMs} ms`);
                    activeOperation = null;
                    return;
                }

                // Plain status change (no active operation)
                const prefix = isError ? '!' : '•';
                appendLogLine(`[${nowClock}] ${prefix} ${label}`);
            }

            function setStatus(text, isError = false, isLoading = false) {
                statusEl.textContent = text || '';
                statusEl.classList.toggle('error', !!isError);
                statusEl.classList.toggle('loading', !!isLoading);
                recordStatus(text || '', !!isError, !!isLoading);
            }

            function escapeHtml(s) {
                return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }

            function clearRender() {
                outputEl.innerHTML = '';
                typesListEl.innerHTML = '';
                nodeMap.clear();
                nodeLines.clear();
                nodeContainers.clear();
                nodeOrder = [];
                nodeIndex.clear();
                selectedNodeIds.clear();
                selectionAnchorId = null;
                try {
                    nodeEditor.value = '';
                    nodeEditor.disabled = true;
                } catch (_) {
                }
                selInfoEl.textContent = '';
                try {
                    if (btnCopySelectionTxt) {
                        btnCopySelectionTxt.disabled = true;
                    }
                    if (btnCopySelectionJson) {
                        btnCopySelectionJson.disabled = true;
                    }
                    if (btnClearSelection) {
                        btnClearSelection.disabled = true;
                    }
                    if (btnTypesLocal) {
                        btnTypesLocal.disabled = true;
                    }
                    if (btnCopyOutputTxt) {
                        btnCopyOutputTxt.disabled = true;
                    }
                    if (btnCopyOutputJson) {
                        btnCopyOutputJson.disabled = true;
                    }
                } catch (_) {
                }
                try {
                    if (typeof closeActivePopover === 'function') {
                        closeActivePopover();
                    }
                } catch (_) {
                }
            }

            function makeNodeId(node, index) {
                // Simple, stable key without position: type#index
                return `${node.type || 'Unknown'}#${index}`;
            }

            function buildLegend(typesInUse) {
                // Global controls are in the popover header; keep checkbox state in sync
                chkShowWhitespace.checked = showWhitespace;

                // Enable present types by default
                visibleTypes = new Set(typesInUse);
                for (const type of KNOWN_TYPES) {
                    document.body.classList.toggle('type-visible-' + type, visibleTypes.has(type));
                }

                for (const type of KNOWN_TYPES) {
                    if (!typesInUse.has(type)) {
                        continue;
                    }
                    const item = document.createElement('label');
                    item.className = 'item';
                    item.dataset.type = type;
                    const check = document.createElement('input');
                    check.type = 'checkbox';
                    check.checked = true;
                    const swatch = document.createElement('span');
                    swatch.className = 'swatch';
                    swatch.style.background = getComputedStyle(document.documentElement).getPropertyValue('--' + type) || '#333';
                    const label = document.createElement('span');
                    label.textContent = type;
                    check.addEventListener('change', () => {
                        if (check.checked) {
                            visibleTypes.add(type);
                        } else {
                            visibleTypes.delete(type);
                        }
                        document.body.classList.toggle('type-visible-' + type, check.checked);
                        updateCollapseStates();
                        ensureSelectedVisible(true);
                    });
                    item.append(check, swatch, label);
                    typesListEl.appendChild(item);
                }
            }

            function renderWhitespaceSpans(target, raw) {
                // Render raw text into target span with visible markers overlaid via CSS
                target.textContent = '';
                let buffer = '';

                function flushBuffer() {
                    if (buffer) {
                        target.appendChild(document.createTextNode(buffer));
                        buffer = '';
                    }
                }

                for (let index = 0; index < raw.length; index += 1) {
                    const ch = raw[index];
                    if (ch === ' ') {
                        flushBuffer();
                        const mark = document.createElement('span');
                        mark.className = 'ws ws-space';
                        mark.textContent = ' ';
                        target.appendChild(mark);
                    } else if (ch === '\t') {
                        flushBuffer();
                        const mark = document.createElement('span');
                        mark.className = 'ws ws-tab';
                        mark.textContent = '\t';
                        target.appendChild(mark);
                    } else {
                        buffer += ch;
                    }
                }
                flushBuffer();
            }

            function applyWhitespaceVisibility() {
                const contents = outputEl.querySelectorAll('.line .content');
                for (const content of contents) {
                    const line = content.closest('.line');
                    if (line && line.classList.contains('page-break')) {
                        continue;
                    }
                    const raw = content.dataset.raw ?? '';
                    if (showWhitespace) {
                        renderWhitespaceSpans(content, raw);
                    } else {
                        content.textContent = raw;
                    }
                }
            }

            // Schedule whitespace rendering to avoid blocking initial paint
            function scheduleWhitespaceRender() {
                const runner = () => applyWhitespaceVisibility();
                const ric = (window && (window.requestIdleCallback || null));
                if (typeof ric === 'function') {
                    ric(runner, {timeout: 250});
                } else {
                    setTimeout(runner, 0);
                }
            }

            // Unified popover helpers (Types, Load From)
            let activePopover = null; // { popEl, anchorBtn, onOpen, initialFocus }
            function positionActivePopover() {
                if (!activePopover) {
                    return;
                }
                const {popEl, anchorBtn} = activePopover;
                const rect = anchorBtn.getBoundingClientRect();
                const scrollX = window.scrollX || window.pageXOffset;
                const scrollY = window.scrollY || window.pageYOffset;
                const left = Math.min(rect.left + scrollX, (window.innerWidth + scrollX) - popEl.offsetWidth - 12);
                const top = rect.bottom + scrollY + 6;
                popEl.style.left = left + 'px';
                popEl.style.top = top + 'px';
            }

            function closeActivePopover() {
                if (!activePopover) {
                    return;
                }
                const {popEl, anchorBtn} = activePopover;
                popEl.classList.remove('open');
                off(document, 'click', onDocClickClose, true);
                off(window, 'resize', positionActivePopover);
                off(window, 'scroll', positionActivePopover, true);
                off(document, 'keydown', onPopoverKeyDown, true);
                off(document, 'focusin', onPopoverFocusIn, true);
                // restore focus
                try {
                    anchorBtn.focus();
                } catch (_) {
                }
                activePopover = null;
            }

            function onDocClickClose(e) {
                if (!activePopover) {
                    return;
                }
                const t = e.target;
                if (activePopover.anchorBtn.contains(t)) {
                    return;
                }
                if (activePopover.popEl.contains(t)) {
                    return;
                }
                closeActivePopover();
            }

            function onPopoverKeyDown(e) {
                if (e.key === 'Escape') {
                    e.stopPropagation();
                    closeActivePopover();
                }
            }

            function onPopoverFocusIn(e) {
                if (!activePopover) {
                    return;
                }
                if (!activePopover.popEl.contains(e.target)) {
                    e.stopPropagation();
                    const focusEl = (typeof activePopover.initialFocus === 'function' ? activePopover.initialFocus() : null) || activePopover.popEl;
                    try {
                        focusEl.focus();
                    } catch (_) {
                    }
                }
            }

            function openPopover(popEl, anchorBtn, opts = {}) {
                closeActivePopover();
                activePopover = {
                    popEl,
                    anchorBtn,
                    onOpen: opts.onOpen || null,
                    initialFocus: opts.initialFocus || null
                };
                popEl.classList.add('open');
                positionActivePopover();
                if (activePopover.onOpen) {
                    try {
                        activePopover.onOpen();
                    } catch (_) {
                    }
                }
                on(document, 'click', onDocClickClose, true);
                on(window, 'resize', positionActivePopover);
                on(window, 'scroll', positionActivePopover, true);
                on(document, 'keydown', onPopoverKeyDown, true);
                on(document, 'focusin', onPopoverFocusIn, true);
                const focusEl = (typeof activePopover.initialFocus === 'function' ? activePopover.initialFocus() : null) || popEl;
                try {
                    focusEl.focus();
                } catch (_) {
                }
            }

            function togglePopover(popEl, anchorBtn, opts) {
                if (activePopover && activePopover.popEl === popEl) {
                    closeActivePopover();
                } else {
                    openPopover(popEl, anchorBtn, opts);
                }
            }

            function filterTypes(query) {
                const q = query.trim().toLowerCase();
                const items = typesListEl.querySelectorAll('label.item');
                for (const item of items) {
                    const name = (item.querySelector('span:last-child')?.textContent || '').toLowerCase();
                    item.style.display = name.includes(q) ? '' : 'none';
                }
            }

            function setLeftWidth(px) {
                currentLeft = px;
                layoutEl.style.gridTemplateColumns = px + 'px 6px 1fr';
            }

            let dragRaf = null;
            let pendingX = null;
            let guideEl = null;
            let dragPos = null;

            function ensureGuide() {
                if (!guideEl) {
                    guideEl = document.createElement('div');
                    guideEl.className = 'splitter-guide';
                    layoutEl.appendChild(guideEl);
                }
                return guideEl;
            }

            function positionGuide(x) {
                const guide = ensureGuide();
                guide.style.left = x + 'px';
            }

            function clampLeft(x, containerWidth) {
                const splitterWidth = 6; // matches CSS
                const maxLeft = containerWidth - splitterWidth - minRightPx;
                return Math.max(minLeftPx, Math.min(x, maxLeft));
            }

            function startDrag(e) {
                isDragging = true;
                containerRect = layoutEl.getBoundingClientRect();
                document.body.classList.add('dragging');
                e.preventDefault();
                const startLeft = currentLeft == null ? Math.round(containerRect.width * 0.5) : currentLeft;
                const clamped = clampLeft(startLeft, containerRect.width);
                dragPos = clamped;
                positionGuide(clamped);
            }

            function applyDrag(x) {
                const clamped = clampLeft(x, containerRect.width);
                dragPos = clamped;
                positionGuide(clamped);
            }

            function onDrag(e) {
                if (!isDragging) {
                    return;
                }
                const clientX = e.clientX ?? (e.touches && e.touches[0]?.clientX);
                if (typeof clientX !== 'number') {
                    return;
                }
                pendingX = clientX - containerRect.left;
                if (dragRaf == null) {
                    dragRaf = requestAnimationFrame(() => {
                        dragRaf = null;
                        if (pendingX != null) {
                            applyDrag(pendingX);
                            pendingX = null;
                        }
                    });
                }
            }

            function endDrag() {
                if (!isDragging) {
                    return;
                }
                isDragging = false;
                document.body.classList.remove('dragging');
                if (dragRaf != null) {
                    cancelAnimationFrame(dragRaf);
                    dragRaf = null;
                }
                if (dragPos != null) {
                    setLeftWidth(dragPos);
                }
                pendingX = null;
                dragPos = null;
                if (guideEl && guideEl.parentNode) {
                    guideEl.parentNode.removeChild(guideEl);
                }
                guideEl = null;
            }

            // Keyboard resizing for accessibility and precision
            splitterEl.addEventListener('keydown', (event) => {
                const step = (event.shiftKey ? 64 : 16);
                if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                    const dir = event.key === 'ArrowLeft' ? -1 : 1;
                    const rect = layoutEl.getBoundingClientRect();
                    const next = clampLeft((currentLeft ?? Math.round(rect.width * 0.5)) + dir * step, rect.width);
                    setLeftWidth(next);
                    event.preventDefault();
                }
            });

            function attachBlockInteractions(blockEl, nodeId) {
                // No per-block listeners; we delegate clicks from the output container.
            }

            function updateSelectionView() {
                for (const [id, el] of nodeContainers.entries()) {
                    el.classList.toggle('selected', selectedNodeIds.has(id));
                }
                if (selectedNodeIds.size === 0) {
                    try {
                        nodeEditor.value = '';
                        nodeEditor.disabled = true;
                    } catch (_) {
                    }
                    selInfoEl.textContent = '';
                    try {
                        if (btnCopySelectionTxt) {
                            btnCopySelectionTxt.disabled = true;
                        }
                        if (btnCopySelectionJson) {
                            btnCopySelectionJson.disabled = true;
                        }
                        if (btnClearSelection) {
                            btnClearSelection.disabled = true;
                        }
                    } catch (_) {
                    }
                    return;
                }
                if (selectedNodeIds.size === 1) {
                    const onlyId = Array.from(selectedNodeIds)[0];
                    const node = nodeMap.get(onlyId);
                    if (node) {
                        try {
                            nodeEditor.disabled = false;
                            if (!suppressEditorUpdate && document.activeElement !== nodeEditor) {
                                nodeEditor.value = JSON.stringify(node, null, 2);
                            }
                        } catch (_) {
                        }
                        selInfoEl.textContent = `${node.type}`;
                        ensureSelectedVisible(false);
                    }
                    try {
                        if (btnCopySelectionTxt) {
                            btnCopySelectionTxt.disabled = false;
                        }
                        if (btnCopySelectionJson) {
                            btnCopySelectionJson.disabled = false;
                        }
                        if (btnClearSelection) {
                            btnClearSelection.disabled = false;
                        }
                    } catch (_) {
                    }
                    return;
                }
                const nodes = [];
                for (const [id] of nodeContainers.entries()) {
                    if (selectedNodeIds.has(id)) {
                        const node = nodeMap.get(id);
                        if (node) {
                            nodes.push(node);
                        }
                    }
                }
                try {
                    nodeEditor.disabled = false;
                    if (!suppressEditorUpdate && document.activeElement !== nodeEditor) {
                        nodeEditor.value = JSON.stringify(nodes, null, 2);
                    }
                } catch (_) {
                }
                selInfoEl.textContent = `${nodes.length} selected`;
                try {
                    if (btnCopySelectionTxt) {
                        btnCopySelectionTxt.disabled = false;
                    }
                    if (btnCopySelectionJson) {
                        btnCopySelectionJson.disabled = false;
                    }
                    if (btnClearSelection) {
                        btnClearSelection.disabled = false;
                    }
                } catch (_) {
                }
            }

            function getSelectedRenderedText() {
                if (!currentAst) {
                    return '';
                }
                if (selectedNodeIds.size === 0) {
                    return '';
                }
                const selectedIdsInOrder = nodeOrder.filter((id) => selectedNodeIds.has(id));
                const parts = [];
                for (const id of selectedIdsInOrder) {
                    const node = nodeMap.get(id);
                    if (!node) {
                        continue;
                    }
                    try {
                        const lines = renderNode(node) || [];
                        parts.push(lines.join('\n'));
                    } catch (_) {
                        // Skip nodes that fail to render
                    }
                }
                return parts.join('\n');
            }

            // Apply edits from the right-panel editor to the current AST and re-render
            function applyNodeEdits(parsedValue) {
                if (!currentAst || !Array.isArray(currentAst.children)) {
                    return;
                }
                if (selectedNodeIds.size === 0) {
                    return;
                }
                // Capture prior visibility and selection to restore after re-render
                const prevVisible = new Set(visibleTypes);
                const prevSelectionIndices = Array.from(selectedNodeIds).map(id => nodeIndex.get(id)).filter(i => typeof i === 'number').sort((a, b) => a - b);
                // Capture editor focus and caret/scroll position to restore after re-render
                const hadFocus = (document.activeElement === nodeEditor);
                const prevStart = (typeof nodeEditor.selectionStart === 'number') ? nodeEditor.selectionStart : 0;
                const prevEnd = (typeof nodeEditor.selectionEnd === 'number') ? nodeEditor.selectionEnd : prevStart;
                const prevScrollTop = nodeEditor.scrollTop || 0;

                // Build mapping of selected indices in render order
                const selectedIdsInOrder = nodeOrder.filter(id => selectedNodeIds.has(id));
                const selectedIndices = selectedIdsInOrder.map(id => nodeIndex.get(id));

                // Helper to validate a node-like object
                function isNodeLike(obj) {
                    return obj && typeof obj === 'object' && typeof obj.type === 'string';
                }

                if (selectedIndices.length === 1 && !Array.isArray(parsedValue)) {
                    if (!isNodeLike(parsedValue)) {
                        throw new Error('Edited JSON must be a node object with a "type" string');
                    }
                    const idx = selectedIndices[0];
                    currentAst.children[idx] = parsedValue;
                    updateRenderedNodeAt(idx, parsedValue);
                } else if (selectedIndices.length > 1 && Array.isArray(parsedValue)) {
                    if (parsedValue.length !== selectedIndices.length) {
                        throw new Error(`Edited array length (${parsedValue.length}) must match selected count (${selectedIndices.length})`);
                    }
                    for (let index = 0; index < parsedValue.length; index += 1) {
                        const obj = parsedValue[index];
                        if (!isNodeLike(obj)) {
                            throw new Error(`Item ${index} is not a valid node object with a "type"`);
                        }
                        const targetIdx = selectedIndices[index];
                        currentAst.children[targetIdx] = obj;
                        updateRenderedNodeAt(targetIdx, obj);
                    }
                } else if (selectedIndices.length > 1 && !Array.isArray(parsedValue)) {
                    throw new Error('Multiple selection expects an array of nodes');
                } else if (selectedIndices.length === 1 && Array.isArray(parsedValue)) {
                    throw new Error('Single selection expects a single node object');
                }
                // Renumber gutters and update collapse states
                recomputeGlobalLineNumbers();
                updateCollapseStates();
                // Re-run validation after edits to capture correct line numbers
                validateDocument();
                // Refresh selection view without clobbering editor
                suppressEditorUpdate = true;
                updateSelectionView();
                suppressEditorUpdate = false;
                // Restore editor focus/caret if it had focus before
                if (hadFocus) {
                    try {
                        nodeEditor.disabled = false;
                        // Defer to next frame so the value set by updateSelectionView is present
                        requestAnimationFrame(() => {
                            nodeEditor.focus();
                            const len = nodeEditor.value.length;
                            const start = Math.max(0, Math.min(prevStart, len));
                            const end = Math.max(0, Math.min(prevEnd, len));
                            nodeEditor.setSelectionRange(start, end);
                            nodeEditor.scrollTop = prevScrollTop;
                        });
                    } catch (_) {
                    }
                }
            }

            // Debounced input handler for the editor
            const onEditorInput = debounce(() => {
                const text = nodeEditor.value;
                if (!text || selectedNodeIds.size === 0) {
                    return;
                }
                try {
                    const value = JSON.parse(text);
                    nodeEditor.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border') || '#1f2430';
                    setStatus('Applying changes...', false, true);
                    applyNodeEdits(value);
                    setStatus('Changes applied');
                } catch (err) {
                    nodeEditor.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--danger') || '#ff6b6b';
                    setStatus('Edit error: ' + (err && err.message ? err.message : String(err)), true, false);
                }
            }, 250);
            nodeEditor.addEventListener('input', onEditorInput);

            // Insert two spaces on Tab within the editor
            nodeEditor.addEventListener('keydown', (event) => {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    try {
                        const start = typeof nodeEditor.selectionStart === 'number' ? nodeEditor.selectionStart : 0;
                        const end = typeof nodeEditor.selectionEnd === 'number' ? nodeEditor.selectionEnd : start;
                        const value = nodeEditor.value || '';
                        const before = value.slice(0, start);
                        const after = value.slice(end);
                        const insert = '  ';
                        nodeEditor.value = before + insert + after;
                        const caret = start + insert.length;
                        nodeEditor.setSelectionRange(caret, caret);
                        // Keep scroll position stable
                        nodeEditor.scrollTop = nodeEditor.scrollTop;
                        // Trigger input pipeline
                        nodeEditor.dispatchEvent(new InputEvent('input', {bubbles: true}));
                    } catch (_) {
                    }
                }
            });

            // Ensure the single selected block is visible with minimal scrolling.
            // If preferCenterWhenOut is true and the block is completely out of view,
            // center it; if partially visible, scroll just enough to fully reveal it.
            function ensureSelectedVisible(preferCenterWhenOut) {
                if (!renderAreaEl) {
                    return;
                }
                if (selectedNodeIds.size !== 1) {
                    return;
                }
                const onlyId = Array.from(selectedNodeIds)[0];
                const block = nodeContainers.get(onlyId);
                if (!block) {
                    return;
                }
                const container = renderAreaEl;
                const containerHeight = container.clientHeight;
                const blockHeight = block.offsetHeight;
                if (blockHeight === 0) {
                    return;
                }
                // If block is larger than the viewport, do not scroll
                if (blockHeight >= containerHeight) {
                    return;
                }
                const margin = 8;
                // Compute block position relative to container scrollTop
                const cRect = container.getBoundingClientRect();
                const bRect = block.getBoundingClientRect();
                const blockTop = (bRect.top - cRect.top) + container.scrollTop;
                const blockBottom = blockTop + blockHeight;
                const viewTop = container.scrollTop;
                const viewBottom = viewTop + containerHeight;
                const fullyVisible = blockTop >= viewTop && blockBottom <= viewBottom;
                if (fullyVisible) {
                    return;
                }
                const completelyOut = (blockBottom <= viewTop) || (blockTop >= viewBottom);
                let nextTop = viewTop;
                if (preferCenterWhenOut && completelyOut) {
                    nextTop = Math.round(blockTop - (containerHeight - blockHeight) / 2);
                } else if (blockTop < viewTop) {
                    // Scroll up just enough plus a small margin
                    nextTop = Math.max(0, Math.round(blockTop - margin));
                } else if (blockBottom > viewBottom) {
                    // Scroll down just enough plus a small margin
                    nextTop = Math.round(blockBottom - containerHeight + margin);
                }
                const maxTop = container.scrollHeight - container.clientHeight;
                nextTop = Math.max(0, Math.min(nextTop, maxTop));
                if (nextTop !== viewTop) {
                    container.scrollTo({top: nextTop, behavior: 'smooth'});
                }
            }

            function toggleSelect(nodeId, event) {
                const isToggle = !!(event && (event.ctrlKey || event.metaKey));
                const isShift = !!(event && event.shiftKey);
                const isLeftClick = !!(event && (event.button === 0 || event.button == null));

                if (isShift && isLeftClick && selectionAnchorId && nodeIndex.has(selectionAnchorId) && nodeIndex.has(nodeId)) {
                    const anchorIndex = nodeIndex.get(selectionAnchorId);
                    const targetIndex = nodeIndex.get(nodeId);
                    const start = Math.min(anchorIndex, targetIndex);
                    const end = Math.max(anchorIndex, targetIndex);
                    const rangeIds = nodeOrder.slice(start, end + 1);
                    if (!isToggle) {
                        selectedNodeIds.clear();
                    }
                    for (const id of rangeIds) {
                        selectedNodeIds.add(id);
                    }
                } else if (isToggle) {
                    if (selectedNodeIds.has(nodeId)) {
                        selectedNodeIds.delete(nodeId);
                    } else {
                        selectedNodeIds.add(nodeId);
                    }
                    selectionAnchorId = nodeId;
                } else {
                    if (selectedNodeIds.size === 1 && selectedNodeIds.has(nodeId)) {
                        selectedNodeIds.clear();
                    } else {
                        selectedNodeIds.clear();
                        selectedNodeIds.add(nodeId);
                    }
                    selectionAnchorId = nodeId;
                }
                updateSelectionView();
                updateCollapseStates();
            }

            function clearSelection() {
                if (selectedNodeIds.size === 0) {
                    return;
                }
                selectedNodeIds.clear();
                updateSelectionView();
                updateCollapseStates();
            }

            // Delegate block clicks to a single handler for better performance
            // Prevent text selection on Ctrl/Cmd or Shift + Left Click to keep range/multi-select crisp
            outputEl.addEventListener('mousedown', (event) => {
                const isLeft = (event && (event.button === 0));
                const hasModifier = !!(event && (event.ctrlKey || event.metaKey || event.shiftKey));
                if (isLeft && hasModifier) {
                    event.preventDefault();
                }
            });
            outputEl.addEventListener('click', (event) => {
                const target = event.target;
                if (!(target instanceof Element)) {
                    return;
                }
                const block = target.closest('.block');
                if (!block || !outputEl.contains(block)) {
                    return;
                }
                const nodeId = block.dataset.nodeId;
                if (!nodeId) {
                    return;
                }
                toggleSelect(nodeId, event);
            });

            function renderAst(ast) {
                // Make rendering a distinct activity in the log
                setStatus('Rendering...', false, true);
                clearRender();
                if (!ast || ast.type !== 'Document' || !Array.isArray(ast.children)) {
                    setStatus('Input must be a Document node with children[]', true);
                    return;
                }
                currentAst = ast;
                const typesInUse = new Set();
                const frag = document.createDocumentFragment();
                let totalLines = 0;

                // Depth-first render: for each child, render its lines and map lines back to the node
                let nodeSerial = 0;

                function renderNodeWithMap(node) {
                    const lines = renderNode(node);
                    const nodeId = makeNodeId(node, nodeSerial++);
                    nodeMap.set(nodeId, node);
                    nodeLines.set(nodeId, []);
                    typesInUse.add(node.type || 'Unknown');

                    const block = document.createElement('div');
                    block.className = 'block';
                    block.dataset.nodeId = nodeId;
                    block.dataset.type = node.type || 'Unknown';
                    nodeContainers.set(nodeId, block);
                    attachBlockInteractions(block, nodeId);
                    nodeOrder.push(nodeId);
                    nodeIndex.set(nodeId, nodeOrder.length - 1);

                    // Type label badge
                    const badge = document.createElement('div');
                    badge.className = 'type-badge';
                    badge.textContent = node.type || 'Unknown';
                    badge.setAttribute('aria-hidden', 'true');
                    badge.setAttribute('role', 'presentation');
                    block.appendChild(badge);

                    // Sibling index (zero-based): use current node's index within its depth
                    const siblingIdx = nodeIndex.get(nodeId) ?? 0;
                    block.dataset.siblingIndex = String(siblingIdx);

                    let lineNumber = 0;
                    for (let index = 0; index < lines.length; index += 1) {
                        const text = lines[index];
                        lineNumber += 1;
                        const lineEl = document.createElement('span');
                        lineEl.className = 'line';
                        lineEl.dataset.nodeId = nodeId;
                        lineEl.dataset.type = node.type || 'Unknown';
                        // Line number gutter
                        const lnEl = document.createElement('span');
                        lnEl.className = 'ln';
                        lnEl.textContent = String(totalLines + 1); // global running count
                        // Content cell
                        const contentEl = document.createElement('span');
                        contentEl.className = 'content';
                        if ((node.type || 'Unknown') === 'PageBreak') {
                            lineEl.classList.add('page-break');
                            contentEl.textContent = '␌'; // SYMBOL FOR FORM FEED to visualize page breaks
                        } else {
                            // Use textContent with white-space: pre to preserve spacing
                            contentEl.dataset.raw = text;
                            if (showWhitespace) {
                                renderWhitespaceSpans(contentEl, text);
                            } else {
                                contentEl.textContent = text;
                            }
                        }
                        // Left index gutter (show sibling index only on the first line of the block)
                        const ixEl = document.createElement('span');
                        ixEl.className = 'ix';
                        ixEl.textContent = (index === 0) ? String(siblingIdx) : '';

                        lineEl.appendChild(ixEl);
                        lineEl.appendChild(lnEl);
                        lineEl.appendChild(contentEl);
                        block.appendChild(lineEl);
                        nodeLines.get(nodeId).push(lineEl);
                        totalLines += 1;
                    }

                    frag.appendChild(block);
                }

                for (const child of ast.children) {
                    renderNodeWithMap(child);
                }

                outputEl.appendChild(frag);
                // Set fixed gutters: left index based on max sibling index, line-number based on total lines
                const digits = Math.max(2, String(totalLines).length);
                outputEl.style.setProperty('--ln-width', (digits + 2) + 'ch');
                const maxIdxDigits = Math.max(1, String(Math.max(0, nodeOrder.length - 1)).length);
                outputEl.style.setProperty('--ix-width', (maxIdxDigits + 1) + 'ch');
                buildLegend(typesInUse);
                updateCollapseStates();
                // Defer whitespace markers to idle time for smoother first paint
                scheduleWhitespaceRender();
                // Validate after initial render
                validateDocument();
                setStatus('Rendered ' + totalLines + ' lines.');
                // Enable header controls only when content exists
                const hasContent = totalLines > 0;
                try {
                    if (btnTypesLocal) {
                        btnTypesLocal.disabled = !hasContent;
                    }
                    if (btnCopyOutputTxt) {
                        btnCopyOutputTxt.disabled = !hasContent;
                    }
                    if (btnCopyOutputJson) {
                        btnCopyOutputJson.disabled = !hasContent;
                    }
                } catch (_) {
                }
            }

            function updateCollapseStates() {
                // Collapse removed — directly hide/show blocks by type visibility
                for (const [nodeId, block] of nodeContainers.entries()) {
                    const type = block.dataset.type || 'Unknown';
                    const visible = visibleTypes.has(type);
                    block.style.display = visible ? '' : 'none';
                }
            }

            function parseAndRenderJson(jsonText) {
                try {
                    setStatus('Parsing JSON...', false, true);
                    const text = (jsonText != null ? String(jsonText) : '').trim();
                    if (!text) {
                        clearRender();
                        setStatus('No input');
                        return;
                    }
                    const ast = JSON.parse(text);
                    renderAst(ast);
                } catch (e) {
                    clearRender();
                    setStatus('Parse error: ' + (e && e.message ? e.message : String(e)), true, false);
                }
            }

            function parseAndRenderTxt(txt) {
                try {
                    setStatus('Parsing text...', false, true);
                    const text = (txt != null ? String(txt) : '');
                    if (!text) {
                        clearRender();
                        setStatus('No input');
                        return;
                    }
                    const normalized = text.replace(/\r?\n/g, '\n').split('\n');
                    const cursor = new ArrayCursor(normalized);
                    const ast = parse(cursor);
                    renderAst(ast);
                } catch (e) {
                    clearRender();
                    setStatus('Parse error: ' + (e && e.message ? e.message : String(e)), true, false);
                }
            }

            // Incremental update of an already-rendered node without re-rendering everything
            function updateRenderedNodeAt(childIndex, newNode) {
                const nodeId = nodeOrder[childIndex];
                if (!nodeId) {
                    return;
                }
                const block = nodeContainers.get(nodeId);
                if (!block) {
                    return;
                }
                nodeMap.set(nodeId, newNode);
                block.dataset.type = newNode.type || 'Unknown';
                const badge = block.querySelector('.type-badge');
                if (badge) {
                    badge.textContent = newNode.type || 'Unknown';
                }

                // Remove existing line elements tracked for this node
                const prevLines = nodeLines.get(nodeId) || [];
                for (const el of prevLines) {
                    if (el && el.parentNode === block) {
                        block.removeChild(el);
                    }
                }
                nodeLines.set(nodeId, []);

                const lines = renderNode(newNode);
                // Insert new line elements after the badge
                const siblingIdx = Number(block.dataset.siblingIndex || '0');
                let insertBefore = null;
                let totalLines = 0; // will recompute globally later
                for (let index = 0; index < lines.length; index += 1) {
                    const text = lines[index];
                    const lineEl = document.createElement('span');
                    lineEl.className = 'line';
                    lineEl.dataset.nodeId = nodeId;
                    lineEl.dataset.type = newNode.type || 'Unknown';
                    const lnEl = document.createElement('span');
                    lnEl.className = 'ln';
                    lnEl.textContent = '';
                    const contentEl = document.createElement('span');
                    contentEl.className = 'content';
                    if ((newNode.type || 'Unknown') === 'PageBreak') {
                        lineEl.classList.add('page-break');
                        contentEl.textContent = '␌';
                    } else {
                        contentEl.dataset.raw = text;
                        if (showWhitespace) {
                            renderWhitespaceSpans(contentEl, text);
                        } else {
                            contentEl.textContent = text;
                        }
                    }
                    const ixEl = document.createElement('span');
                    ixEl.className = 'ix';
                    ixEl.textContent = (index === 0) ? String(siblingIdx) : '';
                    lineEl.appendChild(ixEl);
                    lineEl.appendChild(lnEl);
                    lineEl.appendChild(contentEl);
                    block.insertBefore(lineEl, insertBefore);
                    nodeLines.get(nodeId).push(lineEl);
                    totalLines += 1;
                }
                // Summary removed (was used for collapsed view)
                // Note: validation is run after global renumbering in applyNodeEdits
            }

            function recomputeGlobalLineNumbers() {
                // Renumber all line gutters and update gutter width based on count
                const lineEls = outputEl.querySelectorAll('.line .ln');
                let count = 0;
                for (const ln of lineEls) {
                    count += 1;
                    ln.textContent = String(count);
                }
                const digits = Math.max(2, String(count).length);
                outputEl.style.setProperty('--ln-width', (digits + 2) + 'ch');
            }

            // Validation: enforce 72-char line length, mark offending lines, and list errors
            function validateDocument() {
                // Clear previous flags
                const allLines = outputEl.querySelectorAll('.line');
                for (const line of allLines) {
                    line.classList.remove('error-too-long');
                }
                validationContentEl.innerHTML = '';

                const errors = [];
                for (const line of allLines) {
                    const lnEl = line.querySelector('.ln');
                    const contentEl = line.querySelector('.content');
                    const raw = (contentEl && (contentEl.dataset.raw != null ? contentEl.dataset.raw : contentEl.textContent)) || '';
                    const length = raw.length;
                    if (length > MAX_LINE_LENGTH) {
                        line.classList.add('error-too-long');
                        const ln = Number(lnEl && lnEl.textContent ? lnEl.textContent : '0');
                        errors.push({lineEl: line, lineNumber: ln, length, preview: raw});
                    }
                }

                // Build panel UI
                if (errors.length === 0) {
                    validationSummaryEl.textContent = 'Validation: no errors';
                    const ok = document.createElement('div');
                    ok.className = 'error-item';
                    const okMsg = document.createElement('span');
                    okMsg.className = 'msg';
                    okMsg.textContent = 'No validation errors.';
                    okMsg.style.color = 'var(--ok)';
                    ok.appendChild(okMsg);
                    validationContentEl.appendChild(ok);
                    validationPanelEl.open = false;
                    return;
                }

                validationSummaryEl.textContent = `Validation: ${errors.length} error${errors.length !== 1 ? 's' : ''}`;
                for (const err of errors) {
                    const row = document.createElement('div');
                    row.className = 'error-item';
                    const loc = document.createElement('span');
                    loc.className = 'loc';
                    loc.textContent = `Line ${err.lineNumber}`;
                    const msg = document.createElement('span');
                    msg.className = 'msg';
                    const trimmed = err.preview.replace(/\s+/g, ' ').trim();
                    msg.textContent = `length ${err.length} (> ${MAX_LINE_LENGTH}) — ${trimmed.slice(0, 72)}${trimmed.length > 72 ? '…' : ''}`;
                    const jump = document.createElement('button');
                    jump.className = 'btn-link jump';
                    jump.textContent = 'Jump';
                    jump.addEventListener('click', (e) => {
                        e.preventDefault();
                        scrollToLine(err.lineEl);
                    });
                    row.appendChild(loc);
                    row.appendChild(msg);
                    row.appendChild(jump);
                    validationContentEl.appendChild(row);
                }
                validationPanelEl.open = true; // open when errors exist
            }

            function scrollToLine(lineEl) {
                if (!lineEl) {
                    return;
                }
                const container = renderAreaEl;
                const cRect = container.getBoundingClientRect();
                const lRect = lineEl.getBoundingClientRect();
                const top = (lRect.top - cRect.top) + container.scrollTop - 20;
                container.scrollTo({top: Math.max(0, top), behavior: 'smooth'});
                lineEl.classList.add('flash');
                setTimeout(() => {
                    lineEl.classList.remove('flash');
                }, 1200);
            }

            function toCorsProxy(url) {
                return 'https://no-cors.w-ixx.de/?url=' + encodeURIComponent(url);
            }

            async function fetchUrlText(url) {
                if (!url) {
                    throw new Error('Enter a URL to fetch');
                }
                const effectiveUrl = toCorsProxy(url);
                setStatus('Fetching: ' + effectiveUrl, false, true);
                const response = await fetch(effectiveUrl, {headers: {'Accept': 'text/plain, */*;q=0.1'}});
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ' ' + response.statusText);
                }
                return await response.text();
            }

            btnClear.addEventListener('click', () => {
                clearRender();
                setStatus('Cleared', false, false);
            });
            btnClearSelection.addEventListener('click', () => {
                clearSelection();
            });
            if (btnFetchUrl) {
                btnFetchUrl.addEventListener('click', async () => {
                    const url = urlInput.value.trim();
                    if (!url) {
                        setStatus('Enter a URL to fetch');
                        return;
                    }
                    try {
                        btnFetchUrl.disabled = true;
                    } catch (_) {
                    }
                    btnFetchUrl.classList.add('loading');
                    try {
                        const raw = await fetchUrlText(url);
                        const lower = url.toLowerCase();
                        if (lower.endsWith('.json')) {
                            parseAndRenderJson(raw);
                        } else {
                            parseAndRenderTxt(raw);
                        }
                    } catch (error) {
                        setStatus('Fetch/parse error: ' + ((error && error.message) ? error.message : String(error)), true, false);
                    } finally {
                        btnFetchUrl.classList.remove('loading');
                        try {
                            btnFetchUrl.disabled = false;
                        } catch (_) {
                        }
                    }
                });
                urlInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (!btnFetchUrl.disabled) {
                            btnFetchUrl.click();
                        }
                    }
                });
            }
            // Types popover events (unified)
            if (btnTypesLocal) {
                btnTypesLocal.addEventListener('click', () => {
                    togglePopover(typesPopover, btnTypesLocal, {
                        onOpen: () => {
                            typesFilterEl.value = '';
                            filterTypes('');
                        }, initialFocus: () => typesFilterEl
                    });
                });
            }
            btnTypesAll.addEventListener('click', () => {
                for (const type of KNOWN_TYPES) {
                    if (document.body.classList.contains('type-visible-' + type)) {
                        continue;
                    }
                    document.body.classList.add('type-visible-' + type);
                }
                visibleTypes = new Set(KNOWN_TYPES);
                // Check all checkboxes in the list
                typesListEl.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.checked = true;
                });
                updateCollapseStates();
                ensureSelectedVisible(true);
            });
            btnTypesNone.addEventListener('click', () => {
                for (const type of KNOWN_TYPES) {
                    document.body.classList.remove('type-visible-' + type);
                }
                visibleTypes.clear();
                typesListEl.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updateCollapseStates();
                ensureSelectedVisible(true);
            });
            // Debounced filter input
            typesFilterEl.addEventListener('input', debounce(() => {
                filterTypes(typesFilterEl.value);
            }, 120));
            // Local file: JSON
            if (fileInputJson) {
                fileInputJson.addEventListener('change', async () => {
                    const files = fileInputJson.files;
                    if (!files || files.length === 0) {
                        return;
                    }
                    const file = files[0];
                    await handleLocalJsonFile(file);
                    fileInputJson.value = '';
                });
            }
            // Local file: TXT
            if (fileInputTxt) {
                fileInputTxt.addEventListener('change', async () => {
                    const files = fileInputTxt.files;
                    if (!files || files.length === 0) {
                        return;
                    }
                    const file = files[0];
                    await handleLocalTxtFile(file);
                    fileInputTxt.value = '';
                });
            }
            // Load From dropdown
            if (btnLoadFrom) {
                btnLoadFrom.addEventListener('click', () => {
                    togglePopover(loadPopover, btnLoadFrom, {initialFocus: () => (loadPopover.querySelector('button') || loadPopover)});
                });
            }

            // Clipboard input: JSON (menu)
            if (menuJsonClipboard) {
                menuJsonClipboard.addEventListener('click', async () => {
                    try {
                        setStatus('Reading JSON from clipboard...', false, true);
                        let text = '';
                        try {
                            text = await navigator.clipboard.readText();
                        } catch (_) {
                            text = window.prompt('Paste AST JSON here:') || '';
                        }
                        if (!text) {
                            setStatus('Clipboard is empty', false, false);
                            return;
                        }
                        parseAndRenderJson(text);
                        setStatus('Loaded AST from clipboard', false, false);
                    } catch (error) {
                        setStatus('Clipboard error: ' + (error && error.message ? error.message : String(error)), true, false);
                    }
                });
            }
            // Clipboard input: TXT (menu)
            if (menuTxtClipboard) {
                menuTxtClipboard.addEventListener('click', async () => {
                    try {
                        setStatus('Reading text from clipboard...', false, true);
                        let text = '';
                        try {
                            text = await navigator.clipboard.readText();
                        } catch (_) {
                            text = window.prompt('Paste RFC text here:') || '';
                        }
                        if (!text) {
                            setStatus('Clipboard is empty', false, false);
                            return;
                        }
                        parseAndRenderTxt(text);
                        setStatus('Parsed clipboard text', false, false);
                    } catch (error) {
                        setStatus('Clipboard error: ' + (error && error.message ? error.message : String(error)), true, false);
                    }
                });
            }

            // Dialog openers via menu
            let lastDialogInvoker = null;
            if (menuJsonDialog) {
                menuJsonDialog.addEventListener('click', () => {
                    lastDialogInvoker = document.activeElement;
                    try {
                        jsonDialog.showModal();
                    } catch (_) {
                        jsonDialog.show();
                    }
                    closeActivePopover();
                });
            }
            if (menuTxtDialog) {
                menuTxtDialog.addEventListener('click', () => {
                    lastDialogInvoker = document.activeElement;
                    if (inputTxtEl) {
                        inputTxtEl.value = '';
                    }
                    try {
                        txtDialog.showModal();
                    } catch (_) {
                        txtDialog.show();
                    }
                    closeActivePopover();
                });
            }
            if (menuJsonFile) {
                menuJsonFile.addEventListener('click', () => {
                    if (fileInputJson) {
                        fileInputJson.click();
                    }
                    closeActivePopover();
                });
            }
            if (menuTxtFile) {
                menuTxtFile.addEventListener('click', () => {
                    if (fileInputTxt) {
                        fileInputTxt.click();
                    }
                    closeActivePopover();
                });
            }
            /* old file and clipboard handlers removed in favor of JSON/TXT-specific variants */

            // JSON dialog (optional separate button)
            if (btnOpenJsonDialog) {
                btnOpenJsonDialog.addEventListener('click', () => {
                    // Do not prefill with current AST; start empty to load from
                    inputEl.value = '';
                    lastDialogInvoker = document.activeElement;
                    try {
                        jsonDialog.showModal();
                    } catch (_) {
                        jsonDialog.show();
                    }
                });
            }
            btnDialogLoad.addEventListener('click', (e) => {
                e.preventDefault();
                setStatus('Loading JSON...', false, true);
                try {
                    btnDialogLoad.disabled = true;
                } catch (_) {
                }
                btnDialogLoad.classList.add('loading');
                try {
                    parseAndRenderJson(inputEl.value);
                } finally {
                    btnDialogLoad.classList.remove('loading');
                    try {
                        btnDialogLoad.disabled = false;
                    } catch (_) {
                    }
                    try {
                        jsonDialog.close();
                    } catch (_) {
                    }
                }
            });
            // Close dialog when clicking on backdrop, Escape to close, and restore focus
            jsonDialog.addEventListener('click', (e) => {
                const x = (e && typeof e.clientX === 'number') ? e.clientX : null;
                const y = (e && typeof e.clientY === 'number') ? e.clientY : null;
                if (x == null || y == null) {
                    return;
                }
                const rect = jsonDialog.getBoundingClientRect();
                const inDialog = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
                if (!inDialog) {
                    try {
                        jsonDialog.close();
                    } catch (_) {
                    }
                }
            });
            jsonDialog.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    try {
                        jsonDialog.close();
                    } catch (_) {
                    }
                }
            });
            jsonDialog.addEventListener('close', () => {
                try {
                    lastDialogInvoker && lastDialogInvoker.focus();
                } catch (_) {
                }
            });

            // TXT dialog
            btnDialogLoadTxt.addEventListener('click', (e) => {
                e.preventDefault();
                setStatus('Loading TXT...', false, true);
                try {
                    btnDialogLoadTxt.disabled = true;
                } catch (_) {
                }
                btnDialogLoadTxt.classList.add('loading');
                try {
                    parseAndRenderTxt(inputTxtEl ? inputTxtEl.value : '');
                } finally {
                    btnDialogLoadTxt.classList.remove('loading');
                    try {
                        btnDialogLoadTxt.disabled = false;
                    } catch (_) {
                    }
                    try {
                        txtDialog.close();
                    } catch (_) {
                    }
                }
            });
            txtDialog.addEventListener('click', (e) => {
                const x = (e && typeof e.clientX === 'number') ? e.clientX : null;
                const y = (e && typeof e.clientY === 'number') ? e.clientY : null;
                if (x == null || y == null) {
                    return;
                }
                const rect = txtDialog.getBoundingClientRect();
                const inDialog = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
                if (!inDialog) {
                    try {
                        txtDialog.close();
                    } catch (_) {
                    }
                }
            });
            txtDialog.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    try {
                        txtDialog.close();
                    } catch (_) {
                    }
                }
            });
            txtDialog.addEventListener('close', () => {
                try {
                    lastDialogInvoker && lastDialogInvoker.focus();
                } catch (_) {
                }
            });

            async function handleLocalJsonFile(file) {
                try {
                    setStatus('Reading file: ' + file.name, false, true);
                    const text = await file.text();
                    setStatus('Parsing JSON AST...', false, true);
                    const ast = JSON.parse(text);
                    renderAst(ast);
                    const lineCount = document.querySelectorAll('.output .line').length;
                    setStatus('Loaded JSON. Lines: ' + lineCount, false, false);
                } catch (error) {
                    setStatus('File load/parse error: ' + (error && error.message ? error.message : String(error)), true, false);
                }
            }

            async function handleLocalTxtFile(file) {
                try {
                    setStatus('Reading file: ' + file.name, false, true);
                    const text = await file.text();
                    parseAndRenderTxt(text);
                    const lineCount = document.querySelectorAll('.output .line').length;
                    setStatus('Loaded text file. Lines: ' + lineCount, false, false);
                } catch (error) {
                    setStatus('File load/parse error: ' + (error && error.message ? error.message : String(error)), true, false);
                }
            }

            // Splitter events (mouse + touch)
            splitterEl.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', onDrag);
            window.addEventListener('mouseup', endDrag);
            splitterEl.addEventListener('touchstart', (e) => {
                startDrag(e);
            }, {passive: false});
            window.addEventListener('touchmove', (e) => {
                onDrag(e);
            }, {passive: false});
            window.addEventListener('touchend', endDrag);
            window.addEventListener('touchcancel', endDrag);
            btnSample.addEventListener('click', () => {
                setStatus('Loading sample...', false, true);

                const sample = "\n\n\n\n\n\n" +
                    "Independent Submission                                      J. Schilling\n" +
                    "Request for Comments: 9999                               Example Company\n" +
                    "Category: Example                                         September 2025\n" +
                    "\n" +
                    "                 Lorem Ipsum Dolor Sit Amet\n" +
                    "\n" +
                    "Abstract\n" +
                    "\n" +
                    "   Tenetur Habitasse Ipsum Sollicitudin Inceptos Sapien\n" +
                    "   Aenean Nascetur Eleifend Xiphoides Amet Magnis Posuere Lorem Elit\n" +
                    "   Tellus Egestas Xiphos Tristique\n" +
                    "\n" +
                    "Table of Contents\n" +
                    "\n" +
                    "   1. Lorem Ipsum .....................................................4\n" +
                    "     1.1. Dolor Sit ...................................................6\n" +
                    "   2. Amet Consectetur\n" +
                    "     .................................................................10\n" +
                    "\n" +
                    "Notation and Conventions\n" +
                    "\n" +
                    "   Lorum Nomen\n" +
                    "      Inanis descriptio de rebus fictis et vacuis.\n" +
                    "   Ipsum Signum\n" +
                    "      Nugae sine sensu ad specimen textus implendum.\n" +
                    "\n" +
                    "   - Lorum\n" +
                    "   - Ipsum\n" +
                    "   - Dolor\n" +
                    "\n" +
                    "    Lorem ipsum dolor sit amet, consectetur\n" +
                    "    adipiscing elit, sed do eiusmod tempor\n" +
                    "    incididunt ut labore et dolore magna.\n" +
                    "\n" +
                    "   +--------+                               +---------------+\n" +
                    "   |        |--(A)- Inanis Nexus ---------> |   Exemplum    |\n" +
                    "   | Lorum  |                               |     Ipsum     |\n" +
                    "   |        |<-(B)-- Vacuus Rivus --------- |               |\n" +
                    "   +--------+                               +---------------+\n" +
                    "\n" +
                    "            Figure 1: Exemplum Textus (specimen)\n" +
                    "\n" +
                    "Lorum                         Specimen Series                   [Page 1]\n" +
                    "\f\n" +
                    "RFC 9999                    Lorem Ipsum Dolor Sit Amet\n" +
                    "\n" +
                    "   Nulla facit exemplaria; specimina tantum hic leguntur,\n" +
                    "   textus omnino fictus et vacuus ad usum ostensionis.\n";

                parseAndRenderTxt(sample);
            });

            // Copy: selected node(s) TXT
            if (btnCopySelectionTxt) {
                btnCopySelectionTxt.addEventListener('click', async () => {
                    try {
                        setStatus('Copying selection...', false, true);
                        const text = getSelectedRenderedText();
                        if (!text) {
                            setStatus('No selection to copy', true, false);
                            return;
                        }
                        try {
                            await navigator.clipboard.writeText(text);
                            const lineCount = text.split('\n').length;
                            setStatus(`Copied selection (${lineCount} line${lineCount !== 1 ? 's' : ''})`);
                        } catch (error) {
                            setStatus('Copy failed: ' + (error && error.message ? error.message : String(error)), true, false);
                        }
                    } catch (error) {
                        setStatus('Copy failed: ' + (error && error.message ? error.message : String(error)), true, false);
                    }
                });
            }

            // Copy: selected node(s) JSON
            if (btnCopySelectionJson) {
                btnCopySelectionJson.addEventListener('click', async () => {
                    try {
                        if (selectedNodeIds.size === 0) {
                            setStatus('No selection to copy', true, false);
                            return;
                        }
                        setStatus('Copying selection JSON...', false, true);
                        const jsonText = (nodeEditor && !nodeEditor.disabled) ? (nodeEditor.value || '') : '';
                        if (!jsonText) {
                            setStatus('Editor is empty', true, false);
                            return;
                        }
                        await navigator.clipboard.writeText(jsonText);
                        setStatus('Copied selection JSON');
                    } catch (error) {
                        setStatus('Copy failed: ' + (error && error.message ? error.message : String(error)), true, false);
                    }
                });
            }

            // Removed legacy toolbar copy button; use panel header Copy TXT/JSON

            // Copy: full rendered output TXT (left header)
            if (btnCopyOutputTxt) {
                btnCopyOutputTxt.addEventListener('click', async () => {
                    if (!currentAst) {
                        setStatus('Nothing rendered to copy', true, false);
                        return;
                    }
                    try {
                        setStatus('Copying output...', false, true);
                        const text = renderToString(currentAst);
                        await navigator.clipboard.writeText(text);
                        const lineCount = text.split('\n').length;
                        setStatus(`Copied output (${lineCount} line${lineCount !== 1 ? 's' : ''})`);
                    } catch (error) {
                        setStatus('Copy failed: ' + (error && error.message ? error.message : String(error)), true, false);
                    }
                });
            }

            // Copy: full AST JSON (left header)
            if (btnCopyOutputJson) {
                btnCopyOutputJson.addEventListener('click', async () => {
                    if (!currentAst) {
                        setStatus('Nothing rendered to copy', true, false);
                        return;
                    }
                    try {
                        setStatus('Copying JSON...', false, true);
                        const json = JSON.stringify(currentAst, null, 2);
                        await navigator.clipboard.writeText(json);
                        setStatus('Copied output JSON');
                    } catch (error) {
                        setStatus('Copy failed: ' + (error && error.message ? error.message : String(error)), true, false);
                    }
                });
            }

            // Show whitespace checkbox (global)
            chkShowWhitespace.addEventListener('change', () => {
                showWhitespace = chkShowWhitespace.checked;
                applyWhitespaceVisibility();
            });

            // Init: compute 72ch minimum and set default split
            (function initLayout() {
                function computeMinLeftFromCh() {
                    const probe = document.createElement('div');
                    probe.style.position = 'absolute';
                    probe.style.visibility = 'hidden';
                    probe.style.width = '72ch';
                    probe.style.whiteSpace = 'pre';
                    // Match body/output font preference
                    probe.style.fontFamily = 'Consolas, monospace';
                    probe.style.fontSize = getComputedStyle(document.documentElement).getPropertyValue('--code-size') || '13px';
                    document.body.appendChild(probe);
                    const width = Math.ceil(probe.getBoundingClientRect().width);
                    probe.remove();
                    return Math.max(400, width + 32); // account for padding; clamp to reasonable minimum
                }

                minLeftPx = computeMinLeftFromCh();
                const rect = layoutEl.getBoundingClientRect();
                const splitterWidth = 6; // CSS width
                const maxLeft = rect.width - splitterWidth - minRightPx;
                const desiredDefault = 790; // default left column width in pixels
                const defaultLeft = Math.max(minLeftPx, Math.min(desiredDefault, maxLeft));
                setLeftWidth(defaultLeft);
                window.addEventListener('resize', () => {
                    minLeftPx = computeMinLeftFromCh();
                    const rect2 = layoutEl.getBoundingClientRect();
                    const splitterWidth = 6; // CSS width
                    const maxLeft = rect2.width - splitterWidth - minRightPx;
                    const left = currentLeft == null ? defaultLeft : currentLeft;
                    setLeftWidth(Math.max(minLeftPx, Math.min(left, maxLeft)));
                });
            })();

            // Auto-render sample on load to show UI
            if (AUTO_LOAD_SAMPLE) {
                btnSample.click();
            }
        </script>
    </body>
</html>
